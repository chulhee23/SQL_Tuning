# 2.1 인덱스 구조 및 탐색

이번 장의 핵심은 인덱스 구조와 탐색 원리!

인덱스의 탐색 과정은 단 두 단계!

- 수직적 탐색
- 수평적 탐색

이를 이해한 뒤 인덱스 사용법과 튜닝을 완벽하게 이해하자!



## 2.1.1 미리 보는 인덱스 튜닝

**테이블에서 데이터를 찾는 방법**은 2가지가 존재!

- 테이블 전체 스캔
- 인덱스 이용

테이블 전체 스캔은 튜닝 요소가 적고, 인덱스 이용하는 방법이 튜닝 요소도 많고 기법도 다양!

### 인덱스 튜닝의 2 가지 핵심 요소

- 인덱스? -> 소량의 데이터를 검색할 때!
  - 1장에서 얘기했다!

세부적으로는 여러 가지 있겠지만, 핵심은 2가지!

- 인덱스 스캔 과정에서 발생하는 비효율 줄이거나,
- 테이블 액세스 횟수를 줄이거나!

#### 1. 인덱스 스캔 효율화 튜닝 - 인덱스 스캔 과정에서 발생하는 비효율 줄이기

예시) 시력이 1.0 ~ 1.5 사이 값을 갖고 있고, 이름이 홍길동인 학생을 모두 찾는 경우

- 학생명부를 이름과 시력순 정렬한 경우
  - '홍길동'에 일치하는 학생 찾은 뒤, 시력이 1.0 ~ 1.5 사이인 데이터 바로 찾을 수 있다.

| 이름       | 시력    | 학번      |
| ---------- | ------- | --------- |
| ...        | ...     | ...       |
| **홍길동** | **1.0** | **10123** |
| **홍길동** | **1.1** | **10242** |
| **홍길동** | **1.5** | **20371** |
| 홍나물     | 0.5     | 24213     |

- 학생명부를 시력과 이름 순으로 정렬한 경우

| 시력    | 이름       | 학번      |
| ------- | ---------- | --------- |
| ...     | ...        | ...       |
| 1.0     | 김길동     | 10123     |
| **1.0** | **홍길동** | **10242** |
| 1.1     | 아무개     | 20371     |
| ...     | ...        | ...       |
| **1.2** | **홍길동** | **30212** |
| ...     | ...        | ...       |
| 1.5     | 김개똥     | 12324     |
| **1.5** | **홍길동** | **14253** |

전자의 경우가 훨씬 수월하게, 더 적은 양을 스캔한다!!

#### 2. 랜덤 액세스 최소화 튜닝 - 테이블 액세스 횟수 줄이기

**랜덤 액세스 최소화 튜닝이 인덱스 스캔 효율화보다 중요하다!!**

랜덤 액세스 최소화 하는 편이 성능에 더 큰 영향!

1.0 ~ 1.5 의 시력을 가진 학생 50명, 이름이 홍길동인 학생은 5명, 1.0 ~ 1.5 시력을 가진 홍길동은 2명일 때,

이름 순으로 먼저 정렬이 되어 있었다면? 

훨씬 더 적게 접근할 수 있었다! (5명으로 먼저 필터링!)



#### SQL 튜닝은 랜덤 I/O와의 전쟁

DB 성능이 느리다? -> 디스크 I/O 때문! 특히 인덱스를 많이사용한다면 랜덤 I/O가 중요하다!

DBMS 가 제공하는 기능은 이러한 랜덤 I/O를 극복하기 위해 개발되었다고 할 수 있다.

* NL 조인이 대량 데이터 조인할 때 느린 이유?
  * 이 또한 랜덤 I/O 때문!
    * 다량의 랜덤 엑세스 수행으로 인해 수행 속도가 저하된다!
  * 소트머지 조인과 해시 조인이 이를 극복하기 위해 추가적으로 개발된 것!
    * 각 조인 집합을 한 번 스캔하여 처리하기 때문에 디스크 액세스 측면에서 효율적이 된다는데, 자세한 내용은 4장(조인 튜닝)에서!



## 2.1.2 인덱스 구조

인덱스는 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트!

인덱스가 정렬되어있기 때문에, 범위 스캔이 가능하다! (일부만 읽고 멈출 수 있다!)

B+ Tree 인덱스로 사용한다!

각 블록(노드)의 레코드는 하위 블록에 대한 주소값을 갖고,
키값은 하위 블록에 저장된 키값의 범위를 나타낸다!

그래서 수직적 탐색, 수평적 탐색으로 나누는데
수직적 탐색은 인덱스 스캔 시작 지점을 찾는 과정을, 
수평적 탐색은 데이터를 찾는 과정을 나타낸다!



## 2.1.3 인덱스 수직적 탐색

**인덱스 스캔 시작 지점을 찾는 과정!**

## 2.1.4 인덱스 수평적 탐색

**인덱스에서 본격적으로 데이터를 찾는 과정!**

- 조건절을 만족하는 데이터를 모두 찾기 위해
- ROW ID 를 얻기 위해
  - 인덱스 스캔 이후, 테이블에 액세스 하기 위해서!



## 2.1.5 결합 인덱스 구조와 탐색

2 개 이상의 컬럼을 결합해서 인덱스를 생성할 수도 있다!

인덱스를 구성할 때, "이름 + 성별"로 하든, "성별 + 이름" 으로 하든 읽는 인덱스 블록의 개수는 동일하다!



### 자주 범하는 오류

'인덱스 성별 여자 이름 유관순' 이라는 키워드로 검색할 경우 
"이름 + 성별" 로 결합 인덱스 생성한 경우 "성별 + 이름" 보다 유리하다는 설명이 많다!

물론!!! **비교 연산 횟수**를 줄일 수는 있으나,
**엑셀처럼 평면 구조가 아닌 다단계 구조이기 때문에 읽어야 하는 개수는 동일하다!!**

위에서 시력, 이름일 때와 무엇이 다른가?!
바로 등치 조건이라는 점!
**인덱스 컬럼을 `=` 조건으로 검색하는 경우 인덱스 컬럼의 순서는 중요하지 않다.**

B+Tree 에서 리프 노드까지 수직으로 내려오고, 수평 탐색이 진행할 때 결과적으로 읽는 블록의 수는 동일하기 때문.

