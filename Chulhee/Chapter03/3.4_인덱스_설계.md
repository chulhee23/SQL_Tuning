# 3.4 인덱스 설계

인덱스 설계가 SQL 튜닝의 가장 중요한 부분!



## 3.4.1 인덱스 설계가 어려운 이유

단순하게 인덱스를 마구잡이로 생성하면 안됨!

- DML 성능 저하
- DB 사이즈 증가
- DB 관리 및 운영 비용 상승

등 다양한 문제가 생긴다!

**예시**
한 테이블에 6개 인덱스 달려있는 경우
신규 데이터 입렵 시 인덱스 6개 모두 데이터를 입력해야. 
또한, 정렬 상태를 유지해야하므로 블록에 여유가 없다면 인덱스 분할도 발생!



### 개발단계에서 최적 인덱스 설계의 중요성

- 인덱스 추가
  - 시스템에 부하를 준다
- 인덱스 변경
  - 운영 리스크가 크다
  - 영향 받는 모든 SQL을 모두 찾아 성능을 검증해야하기 때문!



## 3.4.2 가장 중요한 두 가지 선택 기준

인덱스 스캔 방식에는 여러 가지가 있지만, 가장 정상적이고 일반적인 방식은
Index Range Scan
**이를 위해서 인덱스 선두 컬럼을 조건절에 반드시 사용해야 한다!**

따라서 **결합 인덱스를 구성할 때 2가지 기준!**

1. **조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정**
2. **'=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다**



## 3.4.3 스캔 효율성 이외의 판단 기준

위의 기준은 스캔 효율성을 기준으로 판단했다면
그외 판단 기준도 확인해보자!

- 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하 (= 기존 인덱스 개수, 초당 DML발행량, 자주 갱신하는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용

이런 기준에 대해서 설계자 성향 및 스타일 따라서 결과물도 달라진다!

이중 가장 중요한 기준은 **수행빈도!**
자주 수행하지 않는 SQL?  스캔 비효율 감수할 수 있다!

수행빈도와 관련해서,
NL 조인할 때 어느 쪽에서 자주 액세스 되는지도 중요한 판단 기준!
***Outer 보다는 Inner 가 더 중요!***

Inner 쪽 인덱스는 '=' 조건 컬럼을 선두에, 테일블 액세스 없이 인덱스에서 필터링 마치도록 구성해야!



**데이터량도 중요한 기준!**
데이터량이 적으면? 굳이 인덱스 쓸 필요 없이 Full Scan 으로 충분한 성능!



## 3.4.4 공식을 초월한 전략적 설계

조건절 패턴이 10개 있을 때, 각 패턴마다 인덱스? 매우 좋지 않음.

최적을 달성해야할 핵심 액세스 경로를 1~2개 선택해서 최적 인덱스 설계하고,
나머지는 약간의 비효율 감수하고 목표 성능을 만족하는 수준으로 인덱스 구성!

> 일반적으로  '=' 조건이 반드시 앞으로 나와야하지만,
비즈니스 로직에 의해 BETWEEN 조건이 더 중요할 수도 있다!

부동산 계약을 조회하는 로직에서

- 취급부서, 취급지점, 취급자, 입력자, 대리점설계사, 대리점지사 중 하나를 선택
  - '=' 으로 조회해야하는 컬럼
- 청약일자, 보험개시일자, 보험종료일자, 데이터생성일시
  - BETWEEN 조건

`INSERT` 가 자주 발생할텐데 해당 컬럼들에 대한 모든 경우에 대해 인덱스를 만들 것인가?
**NO!**

반대로
**BETWEEN 조건에 해당하는 컬럼을 인덱스 선두 컬럼으로 두고 나머지 자주 쓰는 필터 조건을 뒤쪽에 추가하자!**

이렇게 설계하는 이유?

- 일자 조회 기간(BETWEEN) 이 길지 않으면 인덱스 스캔 비효율이 성능에 미치는 영향이 크지 않다!
  - 서비스적으로 장기간 조회가 거의 없다!
- 인덱스 스캔 효율보다 테이블 액세스가 더 큰 부하 요소가 된다!



## 3.4.5 소트 연산을 생략하기 위한 컬럼 추가

ORDER BY, GROUP BY 연산이 자주 일어난다면?
**인덱스로 애초에 정렬 상태를 유지하고 있으니, 인덱스로 개선해보자!**

```sql
SELECT 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
FROM 계약
WHERE 취급지점ID = :trt_brch_id
AND 청약일자 BETWEEN :sbcp_dt1 and :sbcp_dt2
AND 입력일자 >= trunc(sysdate-3)
AND 계약상태코드 in ( :ctr_stat_cd1, :ctr_stat_cd2, ctr_stat_cd3)
ORDER BY 청약일자, 입력자ID
```

성능 고려 없이 SORT 연산 생략 위해 인덱스만 구성하겠다고 한다면
[청약일자, 입력자 ID]로 구성하면 연산 생략 가능!

이제 성능을 바라보자.

인덱스에서 수직적 스캔을 타고 내려갈 때 Range Scan 이 안된다.
그냥 Index Full Scan 하게 된다! 인덱스가 조건절과 관련 없거든!
따라서, ORDER 된 내용이 앞쪽에서 만나면 일찍 종료하겠지만, 맨 뒤에 있었다면?
I/O가 많이 발생했을 것....

**I/O 연산도 최소화, 소트 연산을 생략하려면?**

- '=' 연산자로 사용한 조건절 컬럼 선정
- ORDER BY 절에 기술한 컬럼 추가
- '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려하여 추가 여부 설정

이렇게 바라보면?

**인덱스 : [취급지점, 청약일자, 입력자 ID]** 으로 구성하면 좋겠네!



### IN 조건은 '=' 이 아니다

> 3.3.8에서 봤던 내용!

위의 쿼리에서 계약 상태 컬럼으로 인덱스 선두에 두면 소트 연산이 생략될까?

정답은 NO!

'=' 으로 풀리려면 IN-List Iterator 로 풀려야하며,
설령 그렇게 되더라도 3개의 집합을 UNION ALL 해야한다! 
이후 다시 ORDER 가 발생....



## 3.4.6 결합 인덱스 선택도

- 선택도?
  - 전체 레코드 중 조건절에 의해 선택되는 레코드 비율
  - **선택도 = 1 / (컬럼 값 종류 개수)**

- 인덱스 선택도
  - 인덱스 컬럼을 모두 '='로 조회할 때 평균적으로 선택되는 비율
  - 선택도가 높은(카디널리티가 높은) 인덱스는 생성해봐야 효율 낮음



### 컬럼 순서 결정 시, 선택도 이슈

결합 인덱스 컬럼 간 순서를 정할 때 선택도가 중요한가?
정답은 중요하지 않다!

> 2.1.5 에서 배웠다!
> 읽게 되는 인덱스 블록의 수는 동일하다!

인덱스를 설계할 때 할 일은
**항상 사용하는 컬럼을 앞쪽에 두고, 그 중 '=' 조건을 앞쪽에 위치 시키는 것이다!**



## 3.4.7 중복 인덱스 제거

#### 완전 중복

한 인덱스가 다른 인덱스를 완전히 포함하면 이는 중복이다.

[A], [A, B], [A, B, C] 이렇게 인덱스가 있다면
3번째 인덱스만 남기고 앞 인덱스 2개는 모두 삭제해도 된다.

#### 불완전 중복

[A, B], [A, C], [A, D] 처럼 인덱스가 있을 때
**A의 카디널리티가 매우 낮다면 사실상 중복!**

굳이 인덱스를 3개씩 구성할 필요 없이 하나의 인덱스로 설계하는 것이 좋다!

