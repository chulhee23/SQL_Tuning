# 2.1 인덱스 구조 및 탐색

인덱스 구조와 탐색 원리에 대해서 알아봅시다.



## 2.1.1 미리 보는 인덱스 튜닝

### 데이터를 찾는 두 가지 방법

테이터베이스 테이블에서 데이터를 찾는 방법은 두 가지입니다.

* 테이블 전체 스캔
* 인덱스 이용

테이블 전체 스캔과 관련해서는 튜닝 요소가 많지 않지만, 인덱스와 관련해서는 튜닝 요소가 매우 많고 기법도 다양합니다.



### 인덱스 튜닝의 두 가지 핵심요소

인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용합니다.

인덱스 튜닝 방법의 핵심 요소는 크게 두 가지로 나뉩니다.

첫 번째는 **인덱스 스캔 효율화 튜닝** 입니다.

학생 테이블에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 예로 들어봅시다.

만약 이름, 시력순으로 정렬해두었다면 홍길동을 먼저 찾은 후 해당 범위 내의 시력을 가진 학생만 찾으면 됩니다.

즉, 소량의 데이터만 스캔할 수 있습니다.

반면에 시력과 이름으로 정렬을 했다면 훨씬 더 많은 데이터 스캔이 일어납니다.



두 번째는 **랜덤 엑세스 최소화 튜닝** 입니다.

이는 테이블 엑세스 횟수를 줄이는 방식으로 튜닝을 하게 됩니다.

다시 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 생각해봅시다.

시력이 1.0~1.5인 학생은 50명이고, 이름이 홍길동인 학생이 5명이라고 가정합시다.

만일 시력순으로 정렬된 테이블과 이름순으로 정렬된 테이블이 있다면 이름순으로 정렬된 테이블을 사용해야 합니다.



둘 모두 중요하지만 더 중요한 하나를 고르자면 두 번째인 랜덤 엑세스 최소화 튜닝입니다.

엑세스하는 것이 성능에 영향을 더 크게 미치기 때문입니다.



### SQL 튜닝은 랜덤 I/O와의 전쟁

데이터베이스 성능이 느린 이유는 디스크 I/O 때문이고, 그 중에서도 랜덤 I/O가 특히 중요합니다.

DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됐다고 해도 과언이 아닙니다.





## 2.1.2 인덱스 구조

인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 엑세스하기 위해 사용하는 오브젝트입니다.

DBMS는 일반적으로 B+Tree 인덱스를 사용합니다.

노드들은 각각 하위 노드의 키 값의 범위를 나타내며, 리프노드들은 데이터를 저장하고 각 리프노드는 연결되어 정렬된 상태를 유지합니다.

더 정확히는 리프노드는 테이블 레코드를 가리키는 주소값, ROWID를 저장하고 있어 바로 테이블 레코드를 찾아갈 수 있습니다.





## 2.1.3 인덱스 수직적 탐색

인덱스 수직적 탐색은 인덱스 스캔 시작지점을 찾는 과정으로 루트노드부터 내려가며 원하는 값을 찾게 됩니다.



## 2.1.4 인덱스 수평적 탐색

인덱스 수평적 탐색은 데이터를 찾는 과정입니다.

수직적 탐색에서 찾은 지점부터 원하는 데이터가 더 안나타날 때까지 수평적으로 스캔합니다.





## 2.1.5 결합 인덱스 구조와 탐색

두 개 이상의 컬럼을 결함하여 인덱스를 만들 수 도 있습니다.

만약 성별과 이름에 결합 인덱스가 걸려 있다고 생각해봅시다.

여자인 사원이 25명, 유관순인 사원이 2명인 경우 결합 인덱스의 순서가 성능에 영향을 미치는지에 대해 알아봅시다.

```SQL
SELECT 이름, 성별
FROM 사원
WHERE 성별 = '여자'
AND 이름 = '유관순'
```



다른 블로그의 많은 글들을 보면, (이름, 성별)이 (성별, 이름)보다 효율적이라고 주장합니다.

하지만 둘의 성능은 같습니다.

인덱스 컬럼을 모두 `=` 조건으로 검색하면 인덱스 컬럼의 순서는 중요하지 않습니다.

결국 리프노드까지 수직적으로 내려온 다음, 수평적으로 해당 데이터를 찾기 때문에 둘의 성능은 동일합니다.