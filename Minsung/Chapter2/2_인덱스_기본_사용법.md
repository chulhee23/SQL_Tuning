# 2.2 인덱스 기본 사용법

## 2.2.1 인덱스를 사용한다는 것

인덱스 칼럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있습니다.

인덱스를 정상적으로 사용한다는 표현은 리프노드 한 지점에서 시작하여, 스캔하다가 중간에 멈추는 것을 말합니다.

즉, 리프노드 일부만 스캔하는 Index Range Scan을 의미합니다.



만약 인덱스 칼럼을 가공한다면 인덱스를 사용할 수는 있지만 스캔 시작점, 종료점을 명시할 수 없어 리프노드 전체를 스캔해야합니다. 

즉 일부가 아닌 전체를 스캔하는 Index Full Scan 방식으로 작동합니다. 



## 2.2.2 인덱스를 Range Scan 할 수 없는 이유

인덱스 칼럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 **인덱스 스캔 시작점을 찾을 수 없기 때문**입니다.

예를 들어 2017년 1월에 태어난 학생을 찾는다면, 2017년 1월 1일 이후 태어난 첫 번째 학생을 찾고, 2월이 나올 때까지 스캔을 진행하면 됩니다.



반면에 5월에 태어난 학생을 찾는다고 가정해봅시다.

이는 인덱스 칼럼을 아래와 같이 가공하게 될 것 입니다.

```SQL
WHERE substr(생년월일, 5, 2) = '05'
```



이 경우, 어디서부터 스캔을 시작할지, 언제까지 할지 명확히 할 수 없습니다.

이는 substr 뿐 아니라 nvl, like, OR 등에도 동일하게 적용됩니다.



### OR 조건에서의 인덱스

아래와 같은 조건을 봅시다.

마찬가지로 어떤 식으로 인덱스를 구성해도 Range Scan을 할 수 없습니다.

``` SQL
WHERE (전화번호 = tel_no OR 고객명 = cust_nm)
```



하지만 아래와 같이 바꾸면 고객명과 전화번호에 대해 각각 Index Range Scan을 수행할 수 있습니다.

```SQL
SELECT *
FROM 고객
WHERE 고객명 = cust_nm
UNION ALL 
SELECT *
FROM 고객
where 전화번호 = tel_no
AND (고객명 <> cust_nm or 고객명 is null)
```





### IN 조건에서의 인덱스

다음으로는 IN 조건을 봅시다.

```SQL
WHERE 전화번호 IN (tel_no1, tel_no2)
```



다음 조건도 수직적 탐색을 통해 한 번에 시작점을 찾을 순 없습니다.

하지만 UNION ALL 방식으로 작성하면 아래와 같이 되고, Index Range Scan이 가능합니다.

```SQL
SELECT *
FROM 고객
WHERE 전화번호 = tel_no1
UNION ALL
SELECT *
FROM 고객
WHERE 전화번호 = tel_no2
```



따라서 실제로는 SQL 옵티마이저가 IN 조건절에도 IN-List Iterator 방식을 사용합니다.

IN-List 개수만큼 Index Range Scan을 반복하여 UNION ALL 방식과 동일하게 동작합니다.



## 2.2.3 더 중요한 인덱스 사용 조건

인데스를 (소속팀, 사원명, 연령) 으로 구성했습니다.

그렇다면 아래 쿼리는 Index Range Scan이 발생할까요?

``` SQL
SELECT 사원번호
FROM 사원
WHERE 사원명  = '홍길동'
```



위 같은 경우, 소속팀으로 우선 정렬하고 소속팀이 같다면 그 안에서 사원명으로 정렬을 하게 됩니다.

즉 소속팀이 다르다면 같은 사원명이더라도 멀리 떨어지게 될 것이고, 결국 Index Range Scan이 불가능해집니다.

즉, Index Range Scan을 위해서는 **선두 컬럼이 조건절**에 있어야 한다는 점입니다.



## 2.2.4 인덱스를 이용한 소트 연산 생략

인덱스를 정렬되어 있기 때문에 앞에서도 봤듯이 Index Range Scan이 가능하고 추가적으로 소트 연산 생략 효과도 있습니다.

옵티마이저는 인덱스 칼럼에 ORDER BY 조건이 있더라도 이미 정렬이 보장되기 때문에 추가적으로 정렬을 수행하지 않습니다.

DESC를 이용하여 역으로 정렬할 때 역시 리프노드 중 가장 오른 쪽 노드를 찾고 역으로 스캔하기 때문에 생략할 수 있습니다.



## 2.2.5 ORDER BY 절에서 칼럼 가공

ORDER BY 절 또는 SELECT 절에서 칼럼을 가공한 경우에도 인덱스를 정상적으로 사용할 수 없는 경우가 있습니다.

(장비번호, 변경일자, 변경순번)으로 인덱스를 설정하였다면 아래의 쿼리는 옵티마이저가 정렬을 생략할 수 있습니다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```



하지만 ORDER BY 절을 아래와 같이 사용한다면 정렬을 생략할 수 없습니다.

```sql
ORDER BY 변경일자 || 변경순번
```





## 2.2.6 SELECT LIST에서 칼럼 가공

(장비번호, 변경일자, 변경순번)으로 인덱스를 설정하였다면 아래 쿼리는 정렬 연산을 따로 수행하지 않습니다.

이 경우에는 가장 좌측 혹은 가장 우측 리프노드까지만 타고 내려가서 하나만 읽고 끝냅니다.

``` SQL
SELECT MIN(변경순번)
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'

SELECT MAX(변경순번)
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
```



하지만 아래와 같은 경우, 형변환 후 찾기 때문에 정렬 연산을 생략할 수 없습니다.

``` SQL
SELECT MIN(TO_NUMBER(변경순번))
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
```



하지만 순서만 바꿔줘도 정렬 연산을 생략할 수 있습니다.

``` SQL
SELECT TO_NUMBER(MIN(변경순번))
FROM 상태변경이력
WHERE 장비번호 = 'C'
AND 변경일자 = '20180316'
```





## 2.2.7 자동 형변환

인덱스 컬럼이 문자형인데 조건절 비교값을 숫자형으로 표현한다면 자동으로 형변환이 됩니다.

결국 형변환이 됨으로서 Index Range Scan이 발생하지 않습니다.

아래 쿼리를 예로 들어봅시다.

```sql
SELECT *
FROM 고객
WHERE 생년월일 = 19821225
```



옵티마이저는 해당 쿼리를 아래와 같이 변경합니다.

```
SELECT *
FROM 고객
WHERE TO_NUMBER(생년월일) = 19821225
```





자동 형변환에 대한 개념은 DBMS마다 다릅니다.

타입이 다르면 컴파일 에러를 발생하는 DBMS도 있고, 오라클 같은 경우는 위와 같이 자동 형변환을 실행합니다.

숫자형과 문자형이 만나면 문자가 숫자로 바뀌고, 

문자형과 날짜형이 만나면 문자가 날짜로 바뀝니다.