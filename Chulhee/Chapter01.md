# SQL 처리과정과 I/O

## 1.1 SQL 파싱과 최적화

### SQL 최적화 과정

1. **sql 파싱**
   - 파싱 트리 생성, 문법 체크, sementic 체크
2. **sql 최적화**
   - **옵티마이저**는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행 계획 생성
   - 실행계획 중 가장 효율적인 것을 선택

3. **로우 소스 생성**
   - 옵티마이저가 선택한 경로를 실행가능한 코드나 프로시저 형태로 포매팅을 한다.



## 1.2 SQL 공유 및 재사용

소프트 파싱 vs 하드 파싱

SQL 내부 최적화 과정의 복잡성 

-> 동시성 높은 온라인 트랜잭션 처리 시스템에서 바인드 변수의 중요성



### 소프트 파싱 vs 하드 파싱

- SGA(System  Global Area)
  - 서버 프로세스와 백그라운드 프로세스가 공통 접근하는 데이터와 제어구조를 캐싱하는 메모리 공간
  - (공유 메모리 공간인가??)
- 라이브러리 캐시
  - SGA 내부 위치
  - SQL 파싱, 최적화, 로우 소스 생성과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리 공간

SQL 이 캐시에서 발견하면 바로 실행단계로 넘어가는 것을 **소프트 파싱**
발견하지 못하면 최적화, 로우 소스 생성을 거쳐 실행하는 것을 **하드 파싱**



### 최적화 과정은 Hard 하다!

하나의 쿼리를 수행할 때도, 실행 경로는 무수히 많기 때문에 각 효율성을 판단, CPU를 많이 소비하게 된다!

따라서 한 번 생성한 프로시저를 버린다? => 매우 비효율!

**따라서 라이브러리 캐시가 필요!**



### 바인드 변수의 중요성

SQL은 따로 이름이 없고, SQL 전체 텍스트가 그 역할을 한다.

-> 조금이라도 바뀐다면(의미적으로 같은데 텍스트가 바뀌면) 새로운 객체가 탄생하는 것과 같다!

따라서, 라이브러리 캐시에서 아래 쿼리는 별도의 공간을 갖는다.

```sql
select * from customer where login_id = 1;
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 1;
```

이는 당연히 매우 비효율!!

파라미터를 받아서 SQL을 작성하는 방법을 제공하는 것이 당연히 더욱 좋을 것이다.

```text
create procedure LOGIN(login_id in varchar2) { ... }
```

위와 같은 프로시저 하나를 공유하는 편이 훨씬 유리하다. 

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1
```

***바인드 변수를 활용해서 value 값을 지정하는 것이 아닌, 변수로 활용하자***

그러면 위 SQL 에 대한 하드 파싱은 단 한번만, 이후 캐싱된 sql 을 사용하여 최적화 과정을 거치지 않기 때문에 성능을 UP 시킬 수 있다.



## 1.3 데이터 저장 구조 및 I/O 메커니즘



### 데이터베이스 저장 구조

데이터를 저장하는데, 어디에 저장될까?

데이터를 저장하려면 먼저 테이블 스페이스를 생성해야한다.

테이블 스페이스는 세그먼트를 담는 컨테이너이며, 여러 개의 데이터 파일(디스크 상의 물리적인 OS파일)로 구성된다.



