# 3.4 인덱스 설계

인덱스 설계는 SQL 튜닝의 하이라이트라고 할 정도로 중요한 부분입니다.

인덱스 설계에 필요한 여러 가지 판단 기준, 공식을 초월한 전략적 설계의 필요성, 방법론 등을 설명합니다.



## 3.4.1 인덱스 설계가 어려운 이유

인덱스가 많아지면 관리비용뿐만 아니라 시스템 부하를 증가시키는 요인이 됩니다.

구체적으로 아래와 같은 문제가 생깁니다.

* DML 성능 저하
* 데이터베이스 사이즈 증가 (디스크 공간 낭비)
* 데이터베이스 관리 및 운영 비용 상승



예를 들어 하나의 테이블에 인덱스가 6개 있다면 하나의 데이터가 입력될 때마다 6개의 인덱스에도 데이터가 입력되야합니다.

게다가 정렬된 상태를 유지해야하므로 수직적 탐색을 통해 입력할 블록을 찾는 과정도 필요합니다.



## 3.4.2 가장 중요한 두 가지 선택 기준

1. 조건절에 항상 사용하거나 자주 사용하는 칼럼을 선정
2. = 조건으로 자주 조회하는 컬럼을 앞 쪽에 배치



## 3.4.3 스캔 효율성 이외의 판단 기준

그 외에는 아래와 같은 판단 기준이 있습니다.

* 수행 빈도
* 업무상 중요도
* 클러스터링 팩터
* 데이터량
* DML 부하
* 저장 공간
* 인덱스 관리 비용



다양한 판단 기준이 있기에 설계자의 성향이나 스타일에 따라 결과물도 크게 달라집니다.

이 중 가장 중요한 하나는 수행 빈도입니다.

자주 수행하지 않는 SQL이면 인덱스 스캔 과정에서 약간의 비효율이 있어도 큰 문제가 아닐 수 있습니다.

수행 빈도와 관련해 NL 조일할 때 어느 쪽에서 자주 액세스 되는지도 중요한 판단 기준이 됩니다.

> NL 조인 부분 추가



데이터량도 인덱스를 설계할 때 중요한 판단 기준입니다.

데이터량이 적다면 인덱스 없이 Full Scan으로도 충분히 빠를 수 있습니다.



## 3.4.4 공식을 초월한 전략적 설계

보험사에서 가계약 목록을 조회한다고 가정합시다.

가계약 목록을 조회할 때는 다양한 방식으로 조회합니다.

우선 드랍다운 리스트에서 취급부서, 취급지점, 취급자, 입력자, 대리점설계사, 대리점지사 중 하나를 선택합니다.

해당 값에 대한 조건절 연산자는 = 입니다.

그리고 청약일자, 보험개시일자, 보험종료일자, 데이터생성일시 중 하나를 선택합니다.

해당 값에 대한 조건절 연산자는 BETWEEN입니다.



모든 경우에 대해서 인덱스를 만든다면 24개의 인덱스가 필요합니다.

가계약 테이블은 INSERT 연산이 많이 발생하므로 이는 부적합합니다.



따라서 아래와 같은 전략적인 접근이 필요합니다.

X01 : 청약일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사

X02 : 보험개시일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사

X03 : 보험종료일자 + 취급부서 + 취급지점 + 취급자 + 입력자 + 대리점설계사 + 대리점지사

X04 : 데이터생성일시 + 취급부서 + 취급지점 + 취급자 +  대리점설계사 + 대리점지사



이렇게 설계한 핵심 포인트는 두 가지입니다.

* 가계약은 주로 최근 3일 이내의 데이터를 조회하기 때문에 일자가 가장 선두에 위치해도 인덱스 스캔량이 그리 많지 않습니다.
* 인덱스 스캔 효율보다 테이블 액세스가 더 큰 부하요소입니다.



또한 위와 같은 판단을 한 이유는, 가계약을 조회할 때 가장 많이 사용하는 패턴은 입력자, 데이터생성일시 조건이기 때문입니다.

따라서 이 패턴에 최적인 아래의 인덱스를 추가한다면 다른 패턴에서 약간의 비효율이 발생해도 큰 문제가 없습니다.

X05 : 입력자 + 데이터생성일시



## 3.4.5 소트 연산을 생략하기 위한 칼럼 추가

인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 해줍니다.

따라서 조건절에 사용하지 않는 칼럼이더라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시켜 성능 개선을 도모할 수 있습니다.

```SQL
SELECT 계약ID, 청약일자, 입력자ID, 계약상태코드, 보험시작일자, 보험종료일자
FROM 계약
WHERE 취급지점ID = :trt_brch_id
AND 청약일자 BETWEEN :sbcp_dt1 and :sbcp_dt2
AND 입력일자 >= trunc(sysdate-3)
AND 계약상태코드 in ( :ctr_stat_cd1, :ctr_stat_cd2, ctr_stat_cd3)
ORDER BY 청약일자, 입력자ID
```



성능을 고려하지 않아도 된다면 소트 연산을 생략하도록 인덱스 구성하기 쉽습니다.

ORDER BY 순서대로 (청약일자, 입력자ID)로 구성하면 됩니다.

= 조건인 취급지점ID인 경우에는 ORDER BY 절에 없더라도 인덱스 구성에 포함되도 상관없습니다.

= 이 아닌 조건절 칼럼들은 ORDER BY 칼럼보다 뒤 쪽에 두어야 합니다.



I/O를 최소화하면서도 소트 연산을 생략하려면 아래 공식에 따라 인덱스를 구성하면 됩니다.

* = 연산자로 사용한 조건절 칼럼 선정
* ORDER BY 절에 기술한 칼럼 추가
* = 연산자가 아닌 조건절 칼럼은 데이터 분포를 고려해 추가 여부 결정



이 공식에 따라 위에서 제시한 SQL에는 인덱스를 (취급지점ID, 청약일자, 입력자ID) 순으로 구성합니다.



### IN 조건은 =이 아니다

위 쿼리에서 계약상태코드는 어떻게 될까요?

IN 조건이 = 이라고 한다면 인덱스 앞 쪽에 두어도 소트연산을 생략할 수 있다고 생각할 수 있습니다.

하지만 IN 조건은 =이 아닙니다.

만일 =으로 된다고 하더라도 각각의 SELECT 쿼리를 UNION ALL하게 될텐데 그 때 정렬이 다시 필요해집니다.



## 3.4.6 결합 인덱스 선택도

인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단기준입니다.

선택도란 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말하며, 선택도에 총 레코드 수를 곱해서 카디널리티를 구합니다.

인덱스 선택도는 인덱스 컬럼을 모두 =로 조회할 때 평균적으로 선택되는 비율을 의미합니다.

선택도가 높은 인덱스는 테이블 액세스가 많이 발생하기 때문에 생성해봐야 효용가치가 별로 없습니다.

따라서 인덱스를 생성할 때는 반드시 선택도를 확인해야합니다.



### 칼럼 순서 결정 시, 선택도 이슈

결합 인덱스 칼럼 간 순서를 정할 때도 선택도가 중요하다고 많이 착각하지만 실제로는 영향이 없습니다.

아래 쿼리에 대해 어느 칼럼이 앞으로 오든 인덱스 스캔 범위는 똑같습니다.

``` SQL
WHERE 성별 = :GENDER
AND 고객번호 = :CUST_NO
```



결론적으로, 인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준입니다.



## 3.4.7 중복 인덱스 제거

아래 3개의 인덱스를 봅시다.

* X01 : 계약ID + 청약일자
* X02 : 계약ID + 청약일자 + 보험개시일자
* X03 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자

X03 인덱스가 나머지 인덱스들을 모두 포함하기 때문에 X01, X02 인덱스는 삭제해도 무방합니다.



이번에는 아래 4개의 인덱스를 봅시다.

* X01 : 계약ID + 청약일자
* X02 : 계약ID + 보험개시일자
* X03 : 계약ID + 보험종료일자
* X04 : 계약ID + 데이터생성일시

겉으로 보기에는 중복이 하나도 없지만 계약ID의 평균 카디널리티가 매우 낮다면 사실상 중복입니다.

예를 들어 계약ID 평균 카니널리티가 5라고 가정합시다. 즉 계약ID를 = 조건으로 조회하면 평균 다섯 건이 조회된다고 합시다.

그렇다면 굳이 인덱스를 4개 운용할 필요없이 하나의 인덱스로 충분합니다.

* X05 : 계약ID + 청약일자 + 보험개시일자 + 보험종료일자 + 데이터생성일시





