# 4.2 소트 머지 조인

조인 컬럼에 인덱스가 없을 때,
대량 데이터 조인이어서 인덱스가 효과적이지 않을 때

**옵티마이저는 NL 조인 대신 소트 머지 조인, 혹은 해시 조인을 선택한다!**

해시 조인이 더 강력하지만, 해시 조인을 쓰지 못하는 상황에선 여전히 좋음!



## 4.2.1 SGA vs PGA

소트머지를 공부하기 전, PGA 에 대한 사전 지식 필요!

- SGA(System Global Area)
  - 서버 프로세스와 백그라운드 프로세스가 공통 접근하는 데이터와 제어구조를 캐싱하는 메모리 공간

- PGA(Process/Program/Private Global Area)

  - 프로세스에 종속적인 고유 데이터를 저장하는 용도

  - PGA 공간이 작아 데이터를 저장하지 못한다면, Temp 테이블 스페이스를 쓰기도 함

  - 독립적인 메모리 공간이므로 SGA 와 다르게 래치(Lock) 메커니즘 불필요!

    > 3.1 latch 내용 참고

  - 같은 양의 데이터를 읽더라도 SGA 버퍼 캐시보다도 빠르다!



## 4.2.2 기본 메커니즘

말 그대로 소트 + 머지 두 단계로 진행!

1. 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬
2. 머지 단계 : 정렬한 양쪽 집합을 서로 머지

`use_merge` 힌트 써서 사용 가능!

```sql
SELECT /* ordered use_merge(c) */
	e.사원번호, e.사원명, e.입사일자
	c.고객번호, c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'  
AND e.부서코드 = '2123'       
AND c.최종주문금액 >= 20000   
```

수행 과정

#### 1단계

```sql
SELECT 사원번호, 사원명, 입사일자
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'  
AND e.부서코드 = '2123'       
AND c.최종주문금액 >= 20000   
ORDER BY 사원번호
```

조건에 해당하는 사원 데이터를 읽어 **조인 컬럼인 사원 번호 순으로 정렬한다.**

**정렬한 결과 집합을 PGA 영역에 할당된 Sort Area 에 저장**
PGA 안에 저장 못할 정도로 정렬한 결과집합이 너무 크면 Temp 테이블 스페이스에 저장!

#### 2단계

c 테이블도 마찬가지로 1단계와 유사한 과정을 거친다.
정렬한 결과 집합은 PGA 영역에 할당된 Sort Area 에 저장.
너무 크면 Temp 에 저장!

#### 3단계

PGA 에 저장된 사원 데이터를 스캔하면서 PGA 저장한 고객 데이터와 조인!



----

Sort Area 에 저장된 데이터 자체가 인덱스 역할을 하므로 
조인 컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식!

**NL 조인 시 조인 컬럼에 인덱스가 있어도 대량 데이터 조인엔 불리한 단점 극복!**



## 4.2.3 소트 머지 조인이 빠른 이유

NL 의 가장 큰 단점인 대량 데이터 조인은 매우 느림!
그래서 이를 개선하기 위해 소트머지, 해시 조인이 개발된 것!

그런데, 소트 머지 조인은 Sort Area 에 미리 정렬해둔 자료 구조를 이용한다는 점만 다르고
프로세싱은 NL 조인과 동일

#### NL 조인 방식

**NL 조인은 "인덱스를 이용한 조인 방식"**

조인 과정에서 액세스하는 **모든 블록을 랜덤 액세스 방식**으로 **건건이 DB 버퍼 캐시를 경유해서 읽는다!**

#### 소트 머지 조인 방식

양쪽 테이블로부터 조인 대상 집합을 일괄적으로 읽어 PGA 에 저장한 뒤 조인!

데이터 읽을 때 PGA 이므로 래치 획득 과정도 없기 때문에 빠르다!

> 소트 머지 실행할 때 정렬해서 Sort Area 저장하는 과정이 
> 어떻게 이미 정렬된 인덱스를 사용하는 것보다 빠르다..?!
>
> 대량 데이터 정렬 nlogn 이 어떻게 정렬된 인덱스보다 빠르지..?
> 잘 모르겠넹...



## 4.2.4 소트 머지 조인의 주용도

NL 조인을 대체하는 소트머지, 해시조인 중 해시 조인이 더 빠르지만,
해시 조인을 못쓸 때 소트머지 조인을 쓴다!

**해시조인은 '=' 조건이 아닐 때 사용할 수 없다!**

따라서 

- 조인 조건식이 등치'=' 조건식이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)

에서 소트 머지 조인을 쓴다!

## 4.2.5 소트 머지 조인 제어하기

```sql
SELECT /* ordered use_merge(c) */
	e.사원번호, e.사원명, e.입사일자
	c.고객번호, c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'  
AND e.부서코드 = '2123'       
AND c.최종주문금액 >= 20000   
```

- `ordered`
  - from 절 기술한 순서대로 조인
  - `leading` 으로 대체 가능
- `use_merge(c)` 로 지시 가능!

양쪽 테이블을 조인 컬럼 순으로 각각 정렬한 후 '정렬된 사원' 기준으로 '정렬된 고객'과 조인하라!



## 4.2.6 소트머지 조인 특징 요약

소트머지 조인은 실시간으로 인덱스를 생성하는 것과 다름없다!

비용
**(소트 부하) <<< (NL 조인 비용)**

소트 머지 조인은 
조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을 때 아주 유리!

> 조인 대상 집합을 줄일 수 있다는게 무슨 의미지??

**스캔 위주의 액세스 방식을 사용하는 것도 중요!**

하지만 모든 처리가 스캔 방식을 하는 건 아님!
양쪽 소스 집합으로부터 조인 대상 레코드를 찾는데 인덱스를 이용할 수도 있고,  그 때는 랜덤 액세스 발생!













