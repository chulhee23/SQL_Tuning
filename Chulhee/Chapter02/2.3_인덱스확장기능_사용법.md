# 2.3 인덱스 확장 기능 사용법

index range scan 말고도, 더 다양한 스캔 방법이 있다!



## 2.3.1 Index Range Scan

지금까지 했던 내용!

B+ Tree 탐색 진행! 수직/ 수평 탐색

성능 -> 스캔 범위 + 테이블 액세스 횟수를 고려해야 한다!



## 2.3.2 Index Full Scan

수직탐색 없이, 리프 노드를 수평적으로 처음부터 끝까지 탐색!

데이터 검색을 위한 최적의 index 가 없을 때 선택되는 방법



#### Index Full Scan 의 효용성

인덱스 선두 컬럼이 조건절에 없으면? 옵티마이저는 바로 **Table Full Scan** 고려!

그런데, 대용량이여서 부담이 크면...?
**인덱스 활용을 다시 고려한다! -> Index Full Scan!**

데이터 저장 공간 = 컬럼 길이 * 레코드 수

인덱스가 차지하는 면적은 당연히 테이블보다는 작다!

따라서 대부분의 레코드를 필터링하고 일부만 액세스 한다면? 인덱스 스캔이 당연히 유리!
(대부분을 액세스하게 된다면 인덱스 스캔이 안좋다는것은 1장에서 알고 있다!)



#### 인덱스 이용한 소트 연산 생략

인덱스는 컬럼 순으로 정렬되어있으므로 Sort Order By 연산 생략할 수 있다!

다만, 많이 읽게된다면? 오히려 느려질 수도~

Ex)

```sql
select /* first_rows */ *
form emp
where sal > 1000
order by ename;
```

위 조건에 해당하는 레코드가 많은 경우, table full scan 이 더 유리!

하지만 first rows 힌트 때문에 첫 레코드 쉽게 추출하기 위해서 옵티마이저에서 index 를 써버린다...

*first rows 힌트 : 첫 레코드 추출할 때 비용이 적게 드는 실행계획을 수립하세요~*



## 2.3.3 Index Unique Scan

데이터를 수직적으로만 탐색!

Unique 인덱스를 `=` 조건으로 탐색할 경우에 작동!

pk 같은 값으로 탐색할 때 많이 쓰겠지?



## 2.3.4 Index Skip Scan

인덱스 선두 컬럼을 조건절에 안쓰면? 옵티마이저는 Table Full Scan or Index Full Scan~

오라클에선 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 사용하고자, 
**Index Skip Scan**을 만들었다!

**인덱스 선두 컬럼의 Distinct Value  개수가 적고, 후행 컬럼의 Distinct Value 개수가 많을 때 유용!**



>  이 부분 보강...



## 2.3.5 Index Fast Full Scan

말 그대로 Index Full Scan 보다 빠른 방식!

- 어떻게??

논리적인 인덱스 트리 구조 무시하고, 세그먼트 전체를 멀티블록 I/O로 스캔하기 때문!

즉, 논리적인 구조가 아닌 디스크에 물리적으로 저장된 순서대로 리프 노드를 읽는다!

양방향 리스트 순서가 무시된 채로 읽어진다.



- 언제 쓰지?
  - 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 효과적!
  - 속도는 빠르지만, 리프 노드가 갖는 연결 리스트 구조를 무시하기 때문에 결과 집합이 인덱스 키 순서대로 정렬되지 않는다.
  - 쿼리에 사용한 컬럼이 모두 인덱스에 포함되어 있을 때만 사용 가능!

- 인덱스가 파티션 되어 있지 않아도 병렬쿼리가 가능!
  - 병렬 쿼리 : 쿼리를 빠르게 처리하기 위해 여러 CPU를 활용하는 실행 계획을 사용

> 이 부분 보강...



## 2.3.6 Index Range Scan Descending

Index Range Scan 내림차순 방법!



