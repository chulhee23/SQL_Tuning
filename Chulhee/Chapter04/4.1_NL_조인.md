# 4.1 NL 조인

조인의 기본은 NL(Nested Loop) 조인!
NL 조인은 인덱스를 이용한 조인이므로 튜닝 원리를 그대로 적용 가능



## 4.1.1 기본 메커니즘

**예시**

사원과 고객 테이블 존재.
1996년 1월 1일 이후 입사한 사원이 관리하는 고객 데이터를 추출하는 프로그램을 작성!

```sql
SELECT e.사원명, c.고객명, c.전화번호
FROM 사원 e, 고객 c
WHERE e.입사일자 >= '19960101'
AND c.관리사원번호 = e.사원번호
```

조인 방법 이전, 어떻게 탐색해야 했을까?

가장 쉽게 접근하는 건 중첩 루프문!

사원 테이블에서 1996년 1월 1일 이후 입사하는 사원 하나씩 찾고, 다시 고객 테이블을 찾는 방법

일반적으로 NL 조인은 Outer(사원 테이블) 와 Inner(고객) 양쪽 테이블 모두 인덱스를 이용한다.

Outer 쪽에선 사이즈가 크지 않으면 인덱스를 이용하지 않을 수도 있음!
Table Full Scan 해도 1번이면 되니까!

Inner 쪽은 반드시 인덱스를 써야한다! 
인덱스 안쓰면? Outer 테이블의 모든 건에 대해서 Table Full Scan 하게 된다!



## 4.1.2 NL 조인 실행 계획 제어

```sql
select /*ordered use_nl(c) */ * 
FROM 사원 e, 고객 c
WHERE e.입사일자 >= '19960101'
AND c.관리사원번호 = e.사원번호
```

- `ordered`
  - from 절에 쓰인 순서대로 조인하라고 기술하는 힌트
  - `leading(c, e)` 로 작성하면 순서를 제어할 수 있다!
- `use_nl`
  - NL 조인 방식 사용
  - `use_hash` 도 존재



## 4.1.3 NL. 조인 수행 과정 분석

NL 조인 수행 과정을 분석해보자

```sql
SELECT /* ordered use_nl(c) index(e) index(c) */
	e.사원번호, e.사원명, e.입사일자
	c.고객번호, c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호 -- 1
AND e.입사일자 >= '19960101'   -- 2
AND e.부서코드 = 'Z123'        -- 3
AND c.최종주문금액 >= 20000     -- 4
```

인덱스 구성

- 사원_PK : 사원번호
- 사원_X1 : 입사일자
- 고객_PK : 고객번호
- 고객_X1 : 관리사원번호
- 고객_X2 : 최종주문금액

 이 때 어떤 인덱스를 쓰고 조건절에선 어느 조건이 먼저 쓰일까?

1. 조건절 번호 (2)
   - 입사일자를 조건으로 먼저 스캔
2. 조건절 번호 (3)
   - **사원_X1인덱스**로 읽은 ROWID로 사원테이블에 엑세스하여 'Z123' 이 맞는지 확인
3. 조건절 번호 (1)
   - 사원번호 값으로 조인 조건을 만족하는 고객 레코드를 찾기 위해 **고객_X1 인덱스**를 range scan 한다
4. 조건절 번호 (4)
   - 고객_X1 인덱스에서 읽은 ROWID로 고객테이블에 액세스하여 필터조건 맞는지 확인

각 단계를 모두 완료하고 넘어가는 것이 아닌,
**한 레코드씩 순차적으로 진행한다!**

>  말 그대로 nested loop 을 생각하면서 고려하자!



## 4.1.4 NL 조인 튜닝 포인트

튜닝 포인트별로 살펴보자!

```sql
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호 -- 1
AND e.입사일자 >= '19960101'   -- 2
AND e.부서코드 = 'Z123'        -- 3
AND c.최종주문금액 >= 20000     -- 4
```

- 사원_PK : 사원번호
- 사원_X1 : 입사일자
- 고객_PK : 고객번호
- 고객_X1 : 관리사원번호
- 고객_X2 : 최종주문금액

#### 1. 사원_X1 을 읽고 나서 테이블에 액세스

단일 컬럼(입사일자) 인덱스를 '>=' 로 스캔하여 비효율 없이 읽고, 랜덤 액세스 발생!

만일 랜덤 액세스가 많았다면? 부서코드 테이블 필터링 많았겠지?? 그럼 당연히 튜닝 필요!

[사원_X1] 인덱스에 부서 코드를 추가해서 개선 가능!

#### 2. 고객_X1 인덱스 탐색

관리 사원 번호 고객_X1 으로 인덱스 탐색은 조인 액세스 횟수가 많을수록 느리다.

만일 3번 조건을 만족하는 레코드가 10만건, 고객_X1 인덱스의 B+ Tree depth가 3이라면?
수직탐색에서만 30만건의 블록을 읽어야한다..!

#### 3. 고객_X1 을 읽고나서 고객 테이블을 액세스

4번 조건에 의해 필터링 되는 비율이 높다면?
고객_X1 인덱스 [관리사원번호] 에 
 [관리사원번호, 최종주문금액] 으로 인덱스를 추가하는 것을 고려해야한다!

#### 4. 처음 액세스하는 사원_X1 에서 얻은 결과에 의해 전체 일량이 좌우

데이터량 많으면? 당연히 전체도 많아지겠지!



### 올바른 조인 메소드 선택

튜닝을 할 때는 NL 조인부터 고려할 것!

수행 일량을 분석해서 과도한 랜덤 액세스 발생하는지 등 확인!
이후 소트 머지나, 해시 조인 등을 검토하자.



## 4.1.5 NL 조인 특징 요약

1. **랜덤 액세스 위주의 조인 방식**
   - 레코드 하나를 읽으려면 블록을 통째로 읽는 랜덤 액세스 방식은
     메모리 버퍼에서 빠르게 읽더라도 비효율적임!
   - **인덱스 구성이 완벽해도 대량 데이터 조인할 때 NL조인이 불리한 이유**
2. **조인을 한 레코드씩 순차 진행**
   - 랜덤 액세스 때문에 대량 데이터 처리 시 치명적인 한계를 나타내지만,
     이 특징 때문에 아무리 큰 테이블을 조인해도 매우 빠른 응답 속도!
   - 부분범위 처리를 활용하면? 매우 좋음!
3. **인덱스 구성 전략**이 다른 조인방식과 비교해서 **매우 중요!**
   - 조인 컬럼에 대한 인덱스 유무, 있다면 컬럼의 구성 등에 따라 효율 크게 다름!



## 4.1.6 NL 조인 튜닝 실습

책 참고



## 4.1.7 NL 조인 확장 메커니즘

버전이 올라가면서 오라클은 NL 성능 높이기 위해서
**테이블 Prefetch, 배치 I/O 기능 도입**

- 테이블 Prefetch
  - 인덱스를 이용해 테이블을 액세스하다가 
    디스크 I/O가 필요해지면 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능
- 배치 I/O
  - 디스크 I/O Call 을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능

> 싱글 블록 I/O의 단점을 없애준다?! 



### NL 조인 자가 진단

인덱스를 [SALE_ORG_ID, STRD_GRP_ID, STRD_ID, STC_DT] 로 구성 요청이 들어왔다.

쿼리는 다음과 같을 때 
인덱스를 어떻게 수정할 수 있을까?

```sql
select * 
from PRA_HST_STC a, ODM_TRMS b
where a.SALE_ORG_ID = :sale_org_id -- 1
and b.STRD_GRP_ID = a.STRD_GRP_ID -- 2
and b.STRD_ID = a.STRD_ID -- 3
order by a.STC_DT desc -- 4
```

> - a 테이블
>   - SALE_ORG_ID, STRD_ID, STC_DT 컬럼 존재
>
> - b 테이블
>   - STRD_GRP_ID, STRD_ID 컬럼 존재
>
> 위에서 언급한 [SALE_ORG_ID, STRD_GRP_ID, STRD_ID, STC_DT]  방식으로는 당연히 구성 불가능.
> 서로 다른 테이블로 어떻게 구성해!
>
> 조건절 비교 순서는 1 - 2(or 3) - 3(or 2) 가 될 것
>
> **outer 테이블 a 에서 SALE_ORG_ID 로 인덱스 구성**,
>
> ROWID 로 테이블 접근 및 STRD_GRP_ID, STRD_ID 읽는다.
>
> 이를 가지고 inner 테이블 b로 갈 때
> **b 테이블 인덱스 [STRD_GRP_ID, STRD_ID]** 를 주면 어떨까?
>
> 마지막으로 정렬 연산을 생략하려면?
> STC_DT 연산 필요할까?
>
> 아님! 조인된 테이블인데! 인덱스 줬다고 빠르게 접근하진 않을듯

