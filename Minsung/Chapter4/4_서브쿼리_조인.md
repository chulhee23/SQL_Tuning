# 4.4 서브쿼리 조인

실무에서는 복잡한 서브쿼리와 조인하는 형태를 흔히 보기 때문에 옵티아미저가 어떻게 처리하는지 이해하고 원하는 방식으로 실행계획을 제어할 수 있어야 튜닝이 가능합니다.

<br>

## 4.4.1 서브쿼리 변환이 필요한 이유

SQL을 여러 형태로 표현할 수 있고 어떤 것을 선택하느냐에 따라 성능도 다릅니다.

따라서 옵티마이저는 비용을 평가하고 실행계획을 생성하기에 앞서 사용자로부터 전달받은 SQL을 최적화에 유리한 형태로 변환하는 작업, 쿼리 변환을 진행합니다.



### 서브 쿼리

서브쿼리는 하나의 SQL문 안에 괄호로 묶은 별도의 쿼리 블록을 말합니다.

* 인라인 뷰 : FROM 절에 사용한 서브 쿼리
* 중첩된 서브쿼리 : WHERE 절에 사용한 서브 쿼리
* 스칼라 서브쿼리 : 한 레코드 당 정확히 하나의 값을 반환하는 서브 쿼리



이들 서브쿼리를 참조하는 메인 쿼리도 하나의 쿼리 블록이며, 옵티마이저는 쿼리 블록 단위로 최적화를 수행합니다.

하지만 서브쿼리별로 최적화한 쿼리가 전체적으로도 최적화됐다고 말할 수 없습니다.

전체적으로 최적화가 필요합니다.

<br>

## 4.4.2 서브쿼리와 조인

### 필터 오퍼레이션

아래는 서브쿼리를 필터 방식으로 처리할 때의 실행계획입니다.

```sql
select c.고객번호, c.고객명
from 고객 c
where c.가입일시 >= trunc(add_months(sysdate, -1, 'mm'))
and exists (
	select /* no_unnest */'x'
  from 거래
  where 고객번호 = c.고객번호
  and 거래일시 >= trunc(sysdate, "mm")
)
```

```
-- Execution Plan
select statement optimizer=ALL__ROWS
	FILTER
  	TABLE ACCESS (BY INDEX ROW)
#   	...
```



필터 오퍼레이션은 기본적으로 NL 조인과 처리 루틴이 같습니다.

단, 두 가지 차이점이 있습니다.

* 필터는 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 진행을 멈추고 메인쿼리의 다음 로우를 계속 처리한다는 점입니다.
* 필터는 서브쿼리 입력 값에 따른 반환 값 true, false를 캐싱하는 기능을 갖는다는 점입니다.

<br>

### 서브쿼리 Unnesting

unnest는 중첩된 상태를 풀어낸다는 뜻입니다.

서브쿼리 unnesting은 메인과 서브쿼리 간의 계층구조를 풀어 서로 같은 레벨로 만들어 준다는 의미입니다.

서브쿼리를 그대로 두면 필터 방식을 사용할 수 밖에 없지만, Unnesting하고 나면 일반 조인문처럼 다양한 최적화 기법을 사용할 수 있습니다. 



Unnesting된 서브쿼리는 다양한 방식으로 실행될 수 있습니다.

Unnesting된 서브쿼리는 메인 쿼리 집합보다 먼저 처리될 수 있습니다.

<br>

### 서브쿼리 Pushing

Unnesting 되지 않은 서브쿼리는 항상 필터 방식으로 처리되며 대개 실행계획 상에서 맨 마지막 단계에 처리됩니다. 

만약 서브쿼리 필터링을 먼저 처리함으로써 조인 단계로 넘어가는 로우 수를 크게 줄일 수 있다면 성능은 그만큼 향상됩니다.      



## 4.4.3 뷰와 조인

최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화합니다.

``` SQL
select c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
from 고객 c
	,(select /*+ merge */ 고객번호, avg(거래금액) 평균거래
    , min(거래금액) 최소거래, max(거래금액) 최대거래
    from 거래
    where 거래일시 >= trunc(sysdate, 'mm') -- 당월 발생한 거래
    group by 고객번호) t
where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm') -- 전월 이후 가입 고객
and t.고객번호 = c.고객번호
```

문제는 고객 테이블에서 '전월 이후 가입한 고객'을 필터링하는 조건이 인라인 뷰 바깥에 있습니다. 

이 조건이 밖에 있는데도 인라인 뷰 안에서는 당월에 거래한 모든 거래의 거래 데이터를 읽어야 합니다.