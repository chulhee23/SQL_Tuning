# 4.1 NL 조인

조인의 기본은 NL 조인입니다.

NL 조인은 인덱스를 이용한 조인이기 때문에 튜닝 원리도 그대로 적용할 수 있습니다.



## 4.1.1 기본 매커니즘

사원 테이블, 고객 테이블이 있다고 가정합시다.

두 테이블에서 1996년 1월 1일 이후 입사한 사원이 관리하는 고객 데이터를 추출하는 프로그램을 작성한다고 가정합시다.

사원 테이블에는 사원번호가 있고, 고객 테이블에는 관리사원번호가 있습니다.



아래 SQL을 사용하면 원하는 결과를 쉽게 얻을 수 있습니다.

```sql
SELECT e.사원명, c.고객명, c.전화번호
FROM 사원 e, 고객 c
WHERE e.입사일자 >= '19960101'
AND c.관리사원번호 = e.사원번호
```



여기서 어떤 알고리즘을 사용하는 것이 좋을까요?

가장 쉽게 생각할 수 있는 방식은, 중첩 루프문을 사용하는 방법입니다.

사원테이블에서 1996년 1월 1일 이후 입사한 사원을 찾아 건건이 고객 테이블에서 사원번호가 일치하는 레코드를 찾는 것이고 이것이 바로 Nested Loop 조인의 알고리즘입니다.

일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용합니다.

Outer 쪽 테이블은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있습니다.

Table Full Scan을 하더라도 그것은 한 번에 그치기 때문입니다.

반면에 Inner 쪽 테이블은 인덱스를 사용해야 합니다. 

인덱스를 사용하지 않으면 Outer 테이블에서 읽은 모든 건에 대해서 Table Full Scan을 반복합니다.





## 4.1.2 NL 조인 실행계획 제어

NL 조인을 제어할 때는 use_nl 힌트를 사용합니다.

```sql
SELECT /*+ ordered use_nl(c) */ *
```



ordered 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할 때 사용합니다.



leading 힌트는 테이블의 조인 순서를 정해줄 수 있습니다.

```sql
SELECT /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_hash(B) */ *
FROM A, B, C, D
```

C와 A는 NL조인, 다시 D와 NL조인, 마지막으로 B와는 해쉬조인을 수행합니다.



## 4.1.3 NL 조인 수행 과정 분석

아래 쿼리의 조건절 비교 순서는 어떻게 될까요?

```SQL
SELECT /* ordered use_nl(c) index(e) index(c) */
	e.사원번호, e.사원명, e.입사일자
	c.고객번호, c.고객명, c.전화번호, c.최종주문금액
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호 -- 1
AND e.입사일자 >= '19960101'   -- 2
AND e.부서코드 = '2123'        -- 3
AND c.최종주문금액 >= 20000     -- 4
```



인덱스 구성은 다음과 같습니다.

* 사원PK : 사원번호
* 사원X1 : 입사일자
* 고객PK : 고객번호
* 고객X1 : 관리사원번호
* 고객X2 : 최종주문금액



1. (2) : 사원X1 인덱스를 통해 입사일자 >= '19960101'인 레코드를 스캔합니다.
2. (3) : 1번의 결과에서 부서코드 = '2123'을 필터 조건으로 스캔합니다.
3. (1) : 사원 테이블에서 찾은 사원번호 값으로 조인조건(c.관리사원번호 = e.사원번호)을 만족하는 고객 쪽 레코드를 찾으려고 고객X1 인덱스를 스캔합니다.
4. (4) : 고객 테이블에서 최종주문금액 >= 20000를 필터 조건으로 스캔합니다.



여기서 주의할 점은 각 단계를 모두 완료하고 다음 단계로 넘어가는 것이 아니라 한 레코드씩 순차적으로 진행한다는 사실입니다.



## 4.1.4 NL 조인 튜닝 포인트

위 예시를 보며 어느 부분에서 튜닝을 할 수 있을지 생각해봅시다.

### 첫 번째 튜닝 포인트

첫 번째 사원X1 인덱스를 읽고 나서 사원 테이블에 액세스 하는 부분입니다.

사원테이블로 아주 많은 양의 랜덤 액세스가 발생했고 부서코드로 필터링되는 비율이 높다면 튜닝의 여지가 있습니다.

사원X1 인덱스에 부서코드 칼럼을 추가해야 할 것입니다.



### 두 번째 튜닝 포인트

두 번째는 고객X1 인덱스를 탐색하는 부분입니다.

고객X1 인덱스를 탐색하는 횟수가 많을수록 성능이 느려집니다.

만약 사원 테이블에서 조건에 만족하는 레코드가 10만 건이고 고객X1 인덱스 Depth가 3이라면 인덱스 수직적 탐색 과정에서만 30만개의 블록을 읽어야하고 리프노드를 스캔하는 과정에서 추가적인 블록I/O가 발생합니다.



### 세 번째 튜닝 포인트

고객X1 인덱스를 읽고 나서 고객 테이블에 액세스하는 부분입니다.

첫 번째와 마찬가지로 최종주문금액에 의해 필터링 되는 부분이 많다면 인덱스에 추가를 고려할 수 있습니다.



가장 중요한 것은 처음 액세스하는 사원 X1 인덱스에서 얻은 결과 건수에 따라 전체 일량이 좌우된다.



### 올바른 조인 메소드 선택

조인 메소드를 선택할 때 NL 조인부터 고려하는 것이 먼저입니다.

NL 조인으로 좋은 성능을 내기 어렵다고 판단될 때 소트 머지 조인이나 해시 조인을 검토합니다.



## 4.1.5 NL 조인 특징 요약

첫 번째 특징은 **랜덤 액세스 위주**의 조인 방식입니다.

레코드 하나를 읽기 위해 블록을 통째로 읽는 랜덤 액세스 방식은 설령 메모리 버퍼에서 빠르게 읽더라도 비효율이 존재합니다.

따라서 인덱스 구성이 아무리 완벽해도 대량 데이터 조인할 때 NL조인이 불리한 이유입니다.



두 번째 특징은 조인을 **한 레코드씩 순차적으로 진행**합니다. 

첫 번째 특징 때문에 대용량 데이터 처리 시 매우 치명적인 한계를 드러내지만,

반대로 이 두 번째 특징으로 부분범위 처리가 가능하다면 빠르게 응답할 수 있습니다.



세 번째 특징은 **인덱스 구성 전략이 특히나 중요**합니다.

조인 칼럼에 대한 인덱스가 있느냐 없느냐, 있다면 칼럼이 어떻게 구성 됐느냐에 따라 조인 효율이 크게 달라집니다.



이러한 특징들로 봤을 때 NL 조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 온라인 트랜잭션 처리 시스템에 적합한 조인 방식입니다.





## 4.1.6 NL 조인 튜닝 실습

## 4.1.7 NL 조인 확장 메커니즘

버전이 올라가면서 올라가면서 오라클은 NL 조인 성능을 높이기 위해 테이블 Prefetch, 배치 I/O 기능을 도입했습니다.

테이블 Prefetch는 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능힙니다.

배치 I/O는 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능입니다.

두 기능 모두 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안되었습니다.

각각 실행계획에서 어떻게 표시되는지 확인해봅시다.



### 전통적인 실행계획

```
NESTED LOOPS
	TABLE ACCESS BY INDEX ROWID OF 사원
		INDEX RANGE SCAN OF 사원X1
  TABLE ACCESS BY INDEX ROWID OF 고객
  	INDEX RANGE SCAN OF 고객X1
```



### 테이블 Prefetch 실행계획

```
TABLE ACCESS BY INDEX ROWID OF 고객
	NESTED LOOPS
		TABLE ACCESS BY INDEX ROWID OF 사원
			INDEX RANGE SCAN OF 사원X1
    INDEX RANGE SCAN OF 고객X1
```



### 배치 I/O 실행계획

```
NESTED LOOPS
	NESTED LOOPS
		TABLE ACCESS BY INDEX ROWID OF 사원
			INDEX RANGE SCAN OF 사원X1
    INDEX RANGE SCAN OF 고객X1
  TABLE ACCESS BY INDEX ROWID OF 고객
```



