# 1. SQL 처리과정과 I/O



## 1.1 SQL 파싱과 최적화

### 1.1.1 구조적, 집합적, 선언적 질의 언어

SQL(Structured Query Language) : 구조적 질의 언어

하지만 결과를 만드는 과정은 절차적이다!

프로시저(과정)을 만들어내는 DBMS 내부 엔진이 옵티마이저!

DBMS 내부에서 프로시저 작성하고, 컴파일, 실행가능하게 만드는 모든 과정을 
**SQL 최적화** 라고 한다!



### 1.1.2 SQL 최적화

1. **sql 파싱**
   - 파싱 트리 생성, 문법 체크, sementic 체크
2. **sql 최적화**
   - **옵티마이저**는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행 계획 생성
   - 실행계획 중 가장 효율적인 것을 선택

3. **로우 소스 생성**
   - 옵티마이저가 선택한 경로를 실행가능한 코드나 프로시저 형태로 포매팅을 한다.



### 1.1.3 옵티마이저

원하는 작업을 가장 효율적으로 수행할  수 있는 최적의 데이터 액세스 경로를 선택해주는 DBMS의 핵심 엔진!

**수행은 어떻게 하지?**

1. **전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획을 찾고,**
2. **미리 수집해 둔** 오브젝트 통계 및 시스템 통계정보를 이용해 실행 계획의 예상 비용을 산정!
3. 최저 비용을 나타내는 실행 계획 선택!



### 1.1.4 실행계획과 비용

DBMS를 통해 실행계획을 미리 볼 수 있습니다.

```sql
explain select id from posts where id > 100;
```



### 1.1.5 옵티마이저 힌트

**옵티마이저는 대부분 좋은 선택을 하지만, 항상 그런 것은 아니다!**

그래서 쿼리 튜닝을 위해서 힌트를 사용하여 직접 지정할 수 있다!!





## 1.2 SQL 공유 및 재사용

소프트 파싱 vs 하드 파싱

SQL 내부 최적화 과정의 복잡성 

-> 동시성 높은 온라인 트랜잭션 처리 시스템에서 바인드 변수의 중요성



### 1.2.1 소프트 파싱 vs 하드 파싱

- SGA(System  Global Area)
  - 서버 프로세스와 백그라운드 프로세스가 공통 접근하는 데이터와 제어구조를 캐싱하는 메모리 공간
  - (공유 메모리 공간인가??)
- 라이브러리 캐시
  - SGA 내부 위치
  - SQL 파싱, 최적화, 로우 소스 생성과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리 공간

SQL 이 캐시에서 발견하면 바로 실행단계로 넘어가는 것을 **소프트 파싱**
발견하지 못하면 최적화, 로우 소스 생성을 거쳐 실행하는 것을 **하드 파싱**



#### 최적화 과정은 Hard 하다!

하나의 쿼리를 수행할 때도, 실행 경로는 무수히 많기 때문에 각 효율성을 판단, CPU를 많이 소비하게 된다!

- 조인 종류, 테이블 스캔 방식, 인덱스 스캔이라면 그 안에도 여러 가지, ... 경우의 수가 정말 많다!

옵티마이저는 다음과 같은 정보를 고려하게 된다!

- 테이블, 컬럼, 인덱스 구조에 대한 정보
- 오브젝트 통계 : 테이블 통계, 인덱스 통계, 컬럼 통계
  - 정확히 어떤 것을 말하는거지..?
- 옵티마이저 관련 파라미터

따라서 한 번 생성한 프로시저를 버린다? => 매우 비효율!

**따라서 라이브러리 캐시가 필요!**



### 1.2.2 바인드 변수의 중요성

SQL은 따로 이름이 없고, **SQL 전체 텍스트가 그 이름 역할**을 한다!

-> 조금이라도 바뀐다면(의미적으로 같은데 텍스트가 바뀌면) **새로운 객체가 탄생하는 것과 같다!**

따라서, 라이브러리 캐시에서 아래 2개의 쿼리는 서로 별도의 공간을 갖는다.

```sql
select * from customer where login_id = 1;
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 1;
```

이는 당연히 매우 비효율!!



파라미터를 받아서 SQL을 작성하는 방법을 제공하는 것이 당연히 더욱 좋을 것이다.

```text
create procedure LOGIN(login_id in varchar2) { ... }
```

위와 같은 프로시저 하나를 공유하는 편이 훨씬 유리하다. 

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1
```

***바인드 변수를 활용해서 value 값을 지정하는 것이 아닌, 변수로 활용하자***

그러면 위 SQL 에 대한 하드 파싱은 단 한번만, 이후 캐싱된 sql 을 사용하여 최적화 과정을 거치지 않기 때문에 성능을 UP 시킬 수 있다.



