# 3.2 부분범위 처리 활용



이번엔 랜덤 액세스로 인한 인덱스 손익분기점의 한계를 극복할 방법인 **부분 범위 처리**를 알아보자!

이를 사용하면 인덱스로 액세스할 대상 레코드가 아무리 많아도 아주 빠른 속도를 낼 수 있다!



## 3.2.1 부분 범위 처리

1억건의 대용량 테이블을 기다리더라도, 빠르게 출력할 수 있는데
이는 DBMS가 데이터를 한번에 전송하지 않고

**먼저 읽는 데이터부터 일정량을 전송하고 멈추기 때문!**

서버 프로세스는 일정량 전송 이후 CPU 를 OS에 반납, 대기큐에서 sleep.
다음 fetch call 을 받으면 그 때 다음 데이터부터 일정량 읽고 반복.

**부분 범위 처리**
: 전체 쿼리 결과집합을 쉼없이 연속적으로 전송하지 않고, 사용자로부터 fetch call 이 있을 때마다 일정량씩 나누어 전송하는 것

```java
Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("select name from big_table");

for (int i = 0; i < 100; i++){
  if (rs.next()) System.out.println(rs.getString(1));
}

rs.close();
stmt.close();
```

1. 최초 `rs.next()` 호출 시 fetch call 통해 db 서버로부터 받은 데이터를 캐시에 저장.
2. 이후 `rs.next()` 호출 시 fetch call 발생시키지 않고 캐시에서 데이터를 읽는다.
3. 캐시에 저장된 데이터가 모두 소진되면,  `rs.next()` 호출 후 fetch call 통해 10건 전송 받는다.

4. 2 ~ 3 번 반복



### 정렬 조건이 있을 때 부분 범위 처리

ordering 이 이뤄지면 전체 데이터 정렬해야한다!

단, 정렬을 하는 컬럼이 선두 인덱스에 있으면 부분 범위 처리가 가능하다.
전체 데이터를 정렬하지 않고도 정렬된 상태의 결과 집합을 바로 전송 가능!



### Array Size 조정을 통한 Fetch Call 최소화

- Array Size를 줄이면? Fetch Call 많아짐!
  - 앞쪽 데이터만 읽고 뒤는 필요없는 경우!
- Array Size 키우면?  Fetch Call 적어짐!
  - 대량 데이터를 파일로 내려받는 경우!

이는 상황에 맞게!



### 쿼리 툴에서 부분 범위 처리

쿼리 툴마다 약간 다름. (따로 쓰지는 않으니 여기서는 생략!)



## 3.2.2 부분범위 처리 구현

java 소스 참고(164 페이지)



## 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능 개선 원리

OLTP : Online Transaction Processing / 온라인 트랜잭션 처리 시스템

온라인 트랜잭션은 일반적으로 소량 데이터를 읽고 갱신!

그런데 종종 대량의 데이터를 조회하는 경우도 존재.

인덱스를 이용해 조회한다면? 많은 테이블의 랜덤 액세스 발생.
하지만, 쿼리 결과 집합이 많을 때 모든 데이터를 일일이 확인하지는 않는다!

그럴 때 항상 정렬 상태를 유지하는 인덱스를 이용하면? 정렬 작업 생략하고 부분범위 처리를 통해 앞쪽 데이터만 아주 빠르게 보여줄 수 있다!



### 멈출 수 있어야 의미있는 부분 범위 처리

 ***앞쪽 일부만 출력하고 멈출 수 있는가?***
이것이 부분 범위 처리의 핵심!

n-Tier 아키텍처에서 클라이언트가 특정 DB 커넥션을 독점할 수는 없다.

단위 작업을 마치면 DB 커넥션을 곧바로 커넥션 풀에 반환해야 하기 때문!
따라서 SQL 조회 결과를 클라이언트에게 모두 전송하고 반환해야함!
그러면 결과 집합을 조금씩 끊어서 전송할 수 있는가?

이는 5.3절에서 확인해보자!



> 부분범위 처리, 페이징보다 좋다는 것 같은데,
> 원리상 완전히 똑같은 것 같기도 하고...?



