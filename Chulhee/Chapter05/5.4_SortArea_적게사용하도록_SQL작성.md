# 5.4 Sort Area 적게 사용하도록 SQL 작성

소트 연산이 불가피하다면 메모리 내에서 처리하는 것이 좋다!
즉, sort area 크기를 늘려도 좋지만, 적게 쓰는게 당연 최고!



## 5.4.1 소트 데이터 주리기

1. select 컬럼을 가공(컬럼의 길이를 늘리는 연산)하고 정렬
2. 정렬한 뒤 select 컬럼가공(컬럼의 길이를 늘리는 연산)

이 중에서 2번이 적게 Sort Area 사용한다.

레코드 당 바이트로 **가공한 결과 집합을 SortArea 에 담기 때문!**

즉 Sort Area 로 가져가는 레코드를 적게 가져가게 만들면 좋다!



## 5.4.2 Top N 쿼리의 소트 부하 경감 원리

인덱스로 소트 연산을 생략할 수 없을 때 Top N 쿼리가 어떻게 동작하는지 보자.

#### 예시

문제 : 학생 1000명 중 키 큰 10명 뽑는다.

- 맨 왼쪽 10명을 뽑고, 정렬한다.
- 990명을 1명씩 차례로 top N 과 비교하면서 해당 위치의 학생을 돌려보내고 새롭게 들어온 학생을 그 위치에 넣는다.

이를 **Top N 소트**라고 하자.

### 페이징 쿼리를 한번 보자

```sql
select * from (
	select rownum no, a.* 
  from 
  (
  	/* SQL Body*/
  ) a
  where rownum <= (:page * 10)
)
where no >= (:page - 1) * 10 + 1
```

- 인덱스로 소트를 생략 못했을 때 table full scan 이 발생

- 실행계획엔 Sort Order By 오퍼레이션 발생

- Stopkey 가 실행계획에 나타나는데, 이는 Top N 이 동작한다는 것

  - page 변수가 1이였다면, 10개 레코드 담을 배열의 공간만 필요!

  - > Sort Area 내 비용을 말하는 거겠지?

  - 대상 집합이 아무리 커도 메모리 공간이 많이 필요하지 않다.

  

## 5.4.3 Top N 쿼리가 아닐 때 발생하는 소트 부하

Stopkey가 사라지면 메모리 내에서 정렬은 완료했지만 디스크를 이용해서 Physical Read 와 Physical Write 둘다 발생!



## 5.4.4 분석함수에서의 Top N 소트

윈도우 함수 중 rank 나 row_number 함수는 max 함수보다 Top N 소트 알고리즘이 동작해서 소트 부하가 적다.

