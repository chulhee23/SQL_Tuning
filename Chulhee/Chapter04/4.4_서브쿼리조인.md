# 4.4 서브쿼리 조인

실무에서는 복잡한 서브쿼리와 조인하는 형태를 보게 된다.

옵티마이저가 서브쿼리 조인을 어떻게 처리하는지 이해하고, 
원하는 방식으로 실행계획을 제어할 수 있어야 튜닝도 가능하다!



## 4.4.1 서브쿼리 변환이 필요한 이유

하나의 결과 집합을 얻기 위해 하나의 SQL 이 여러 형태로 표현될 수 있고, 어떤 것을 선택하느냐에 따라 성능도 다를 수 있다. 
따라서 옵티마이저는 비용을 평가하고 실행계획을 생성하기에 앞서 
사용자로부터 전달받은 SQL을 최적화에 유리한 형태로 변환하는 작업을 실행한다!

**쿼리 변환**

옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성!



### 서브 쿼리

하나의 SQL 문 안에 괄호로 묶은 별도의 쿼리 블록

- 쿼리에 내장된 또 다른 쿼리!

DBMS 마다 조금씩 다르게 분류하지만, 오라클에선 3개로 분류한다.

- 인라인 뷰
  - FROM 절에 사용한 서브쿼리
- 중첩된 서브쿼리
  - 결과 집합을 한정하기 위해 where 절에 사용한 서브쿼리
  - 서브쿼리가 메인쿼리 컬럼을 참조하는 형태는 특히 '상관관계 있는 서브쿼리'라고 한다
- 스칼라 서브쿼리
  - 한 레코드 당 정확히 하나의 값을 반환하는 서브쿼리
  - 주로 `select` 에서 사용하지만, 몇 가지 예외사항 제외하면 컬럼이 올 수 있는 대부분 위치에 사용가능!

이러한 서브쿼리를 참조하는 메인 쿼리도 하나의 쿼리 블록, 
**옵티마이저는 쿼리 블록 단위로 최적화 수행**

서브쿼리별로 최적화한 쿼리가 전체적으로 최적화되었다고 하지 않는다!
최적화할 때는 전체 쿼리를 바라보면서 최적화가 필요하기에, 서브쿼리를 먼저 풀어내야 한다!



## 4.4.2 서브쿼리와 조인

메인 쿼리와 서브쿼리  간엔 종속적이고, 계층적인 관계 존재

서브 쿼리는 단독으로 실행할 수 없으며,
메인 쿼리 건수만큼 값을 받아 반복적으로 필터링하는 방식으로 실행해야 한다!

### 필터 오퍼레이션

서브쿼리를 필터 방식으로 처리할 때 실행 계획!
(최적화 통해서 서브쿼리가 풀리는 것을 방지하기 위해 `no_unnest` 라는 힌트를 사용할 수 있다.)                                                                                          

```sql
select c.고객번호, c.고객명
from 고객 c
where c.가입일시 >= trunc(add_months(sysdate, -1, 'mm'))
and exists (
	select /* no_unnest */'x'
  from 거래
  where 고객번호 = c.고객번호
  and 거래일시 >= trunc(sysdate, "mm")
)
```

```sql
-- Execution Plan
select statement optimizer=ALL__ROWS
	FILTER
  	TABLE ACCESS (BY INDEX ROW)
#   	...
```

필터 동작은 기본적으로 NL 조인과 처리 루틴이 동일하다.

Filter 부분을 Nested loops 로 치환하고 해석하면 된다.

그런데 차이점은?

1. **로우와 조인에 성공하면? 진행을 멈추고 메인 쿼리의 다음 로우를 계속 처리!!**

2. **필터는 캐싱 기능을 갖는다!**
   - 서브쿼리 입력 값에 따른 반환 값을 캐싱하는 기능
   - 서브쿼리를 수행하기 전에 항상 캐시부터 확인한다
   - 캐시에서 true/false 여부를 확인하면 서브쿼리를 수행하지 않아도 된다!
   - 캐싱은 쿼리 단위로! 시작시 PGA 에 공간 할당, 쿼리 끝나면 공간 반납
3. 서브쿼리는 메인 쿼리에 종속적이기에 조인 순서가 항상 고정된다!



### 서브쿼리 Unnesting

`unnest` 를 사용하면 메인과 서브쿼리 간 계층구조를 풀어서 사용하겠다!

이 경우 서브쿼리가 풀리기 때문에(**Flatten**) 필터 방식이 아닌, 일반 조인문처럼 다양한 최적화 기법을 사용할 수 있다.

책의 예제에선 NL 세미 조인을 활용!

**NL 세미 조인**은 기본적으로 NL 조인과 같은 프로세스!
조인에 성공하는 순간 진행을 멈추고 메인 쿼리의 다음 로우를 계속 처리한다는 점만 다름! (필터 오퍼레이션 1번 동작!)

#### Unnesting 하는 이유?

NL 세미 조인외에도 다양한 방식으로 실행될 수 있기 때문!

Unseating 된 서브쿼리는 메인 쿼리 집합보다 먼저 처리될 수 있다!

```sql
select /* leading(거래@subq) use_nl(c) */ c.*
	from 고객 c
	where exists (
    select /* qb_name(subq) unnest */ 'x'
    from 거래
    where # ...
  )
```

위 쿼리는 unnesting 된 쿼리가 드라이빙 되도록 leading 힌트를 쓴 쿼리!

위처럼 조인 형태로 변환했을 때 옵티마이저가 더 좋은 실행경로를 찾을 가능성이 높아진다!

> 따로 힌트 안줘도 옵티마이저가 통계 정보 토대로 위와 같은 내용을 만들어서 찾을 수도 있겠지?



### 서브쿼리 Pushing

unnesting 되지 않은 서브쿼리는 항상 **필터방식** 으로 처리되며, 
주로 실행계획상 맨 마지막에 처리된다.

만일 서브 쿼리 필터링을 먼저 처리할 수 있다면? 
조인 단계로 넘어가는 로우 수를 크게 줄이는 필터링이 이뤄지면 성능은 그만큼 향상!

`push_subq` 라는 힌트로 진행!

- 서브 쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능
- unnesting 되지 않은 서브쿼리에만 작동
  - 따라서, `push_subq` 는 `no_unnest` 힌트와 같이 기술해야 한다!





## 4.4.3 뷰(View)와 조인

최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰 쿼리를 변환하지 않으면, 
뷰 쿼리 블록을 독립적으로 최적화한다.

```sql
select c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
from 고객 c
	,(select 고객번호, avg(거래금액) 평균거래
    , min(거래금액) 최소거래, max(거래금액) 최대거래
    from 거래
    where 거래일시 >= trunc(sysdate, 'mm') -- 당월 발생한 거래
    group by 고객번호) t
where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm') -- 전월 이후 가입 고객
and t.고객번호 = c.고객번호
```

문제는 고객 테이블에서 '전월 이후 가입한 고객'을 필터링하는 조건이 인라인 뷰 바깥에 있다.
**이 조건이 밖에 있는데도** 인라인 뷰 안에서는 당월에 거래한 **모든** 거래의 거래 데이터를 읽어야 한다.

아래는 **merge 힌트**를 이용해 뷰를 메인 쿼리와 머징하도록 했다. 

```sql
select c.고객번호, c.고객명, t.평균거래, t.최소거래, t.최대거래
from 고객 c
	,(select /*+ merge */ 고객번호, avg(거래금액) 평균거래
    , min(거래금액) 최소거래, max(거래금액) 최대거래
    from 거래
    where 거래일시 >= trunc(sysdate, 'mm') -- 당월 발생한 거래
    group by 고객번호) t
where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm') -- 전월 이후 가입 고객
and t.고객번호 = c.고객번호
```

를 통해 처리하면 쿼리는 아래와 같이 변환되었음을 알 수 있다!

```sql
select c.고객번호, c.고객명
	, avg(t.거래금액) 평균거래, min(t.거래금액) 최소거래, max(t.거래금액) 최대거래
from 고객 c, 거래 t
where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm')
and t.고객번호 = c.고객번호
and t.거래일시 trunc(sysdate, 'mm')
group by c.고객번호, c.고객명
```

이 경우 단점은 조인에 성공한 전체 집합을 group by 하고서야 데이터를 출력할 수 있다는 데 있다. 
**부분 처리가 불가능**

> 음... 이건 group by 의 단점인가?
> 아니면 해당 쿼리에서의 단점인가?



### 조인 조건 Pushdown

오라클 11g 이후로 '조인 조건 Pushdown'이라는 쿼리 변환 기능이 작동!

- 메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어넣는 기능
- 실행 계획상 **'VIEW PUSHED PREDICATE'** 오퍼레이션을 통해 알 수있다.

이 방식을 사용하면 전월 이후 가입한 고객을 대상으로 **'건건이' 당월 거래 데이터만 읽어서 조인하고 group by를 수행한다.**

**그러면? 부분처리가 가능!**

뷰 머징할 때 처럼 성공한 전체 집합을 group by 하지 않는다!

> 위에서 궁금했던 내용!
>
> group by 를 쓰면 무조건 그런 것이 아니라,
> 전체 집합에 대해서 group by 이기 때문에 부분처리가 불가능했던 것
>
> 비슷하게 예전에 order? 관련해서 뭐 봤던 거 같은데 기억이 안나넹...
> 기억나면 수정해두기!





## 4.4.4 스칼라 서브쿼리 조인

**스칼라 서브쿼리**

- 한 레코드 당 정확히 하나의 값을 반환하는 서브쿼리
- 주로 `select` 에서 사용하지만, 몇 가지 예외사항 제외하면 컬럼이 올 수 있는 대부분 위치에 사용가능!



### (1) 스칼라 서브쿼리의 특징

`GET_DNAME`이라는 함수가 만들어져 있다고 해보자.

`GET_DNAME` 함수를 실행하는 쿼리를 실행하면
함수 내 select 쿼리를 메인 쿼리 건수만큼 재귀적으로 반복 실행한다.

```sql 
select empno, GET_DNAME(e.deptno) as dname
from emp e
where sal >= 2000
```

반면 아래 스칼라 서브쿼리는 메인 쿼리 레코드마다 정확히 하나의 값만 리턴한다!
**메인 쿼리 건수만큼 DEPT 테이블을 반복해서 읽는 측면에서 함수와 비슷해 보이지만, 재귀 구조는 아님!**

컨텍스트 스위칭 없이 메인쿼리와 서브쿼리를 한 몸체처럼 실행한다!

> 컨텍스트 스위칭 없다는게 무슨 말이지?
>
> 원래는 다른 작업으로 인식해서 컨텍스트 스위칭이 발생했던건가...?

```sql
select empno, (select d.dname from dept d where d.deptno = e.deptno) as dname
from emp e
where sal >= 2000
```

조인 쿼리로 같은 결과 나오게 작성할 수 있는 쿼리인데, 스칼라 서브쿼리는 처리 과정에서 캐싱 작용이 일어난다!

> 조인쿼리나 서브쿼리 결과집합은 같지만 캐싱작용이 일어난다...?
> 서브쿼리가 무조건 좋은가?
> 옵티마이저가 이건 그냥 캐싱되도록 처리하면 안되나?
>
> 밑에서 확인 가능!



### (2) 스칼라 서브쿼리 캐싱 효과

스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화 하려고 입력값과 출력값을 내부 캐시에 저장해둔다.
조인할 때마다 일단 캐시에서 검색하고, 찾지 못하면 그 때 조인 수행!

'스칼라 서브쿼리 캐싱'은 위에서 본 '서브쿼리 캐싱'과 같은 기능!



#### 많이 사용하는 튜닝기법

select-list 에 사용한 함수는 메인 쿼리 결과 건수만큼 반복 수행하는데, **스칼라 서브쿼리를 덧씌우면 호출 횟수를 최소화할 수 있다!**

```sql
select empno, sal, (select GET_DNAME(e.deptno) from dual) dname
from emp e
where sal >= 2000
```



```sql
-- 캐싱 안된 경우와 쿼리 비교해보면, (처음에 본 재귀적 호출)
select empno, GET_DNAME(e.deptno) as dname
from emp e
where sal >= 20000
```



### (3) 스칼라 서브쿼리 캐싱 부작용

**캐시 공간은 늘 부족하다!**

스칼라 서브쿼리 캐싱 효과는 입력 값의 종류가 소수여서 해시 충돌 가능성이 작을 때 효과 있다!
반대의 경우라면 캐시를 매번 확인하는 비용이 더 들게 된다!
(캐시도 확인하고, 없으니 원래 작업도 해야하고~)

> 아하! 옵티마이저에선 (아마도) 이걸 알지 못하니, 조인 쿼리로 할지, 서브쿼리로 할지 선택해야할 것 같네?!



### (4) 두 개 이상의 값 반환

스칼라 서브쿼리는 1개밖에 반환 못한다!

#### (4-1) 문자열 합쳐서 substr

그렇다면??

```sql
select c.고객번호, 
  (select avg(거래금액) from 거래 
   -- ....
  ),
  (select min(거래금액) from 거래 
   -- ....
  ),
  (select max(거래금액) from 거래 
   -- ....
  ),
from 고객 c 
```

와 같이 같은 거래 테이블에서 같은 데이터를 반복해서 읽는 행위는 매우 비효율적!

따라서 구하는 값을 모두 문자열로 결합하고, 바깥쪽 액세스 쿼리에서 substr 함수로 다시 분리한다!

```sql
select to_number(substr(거래금액, 1, 10)) 평균거래금액
, to_number(substr(거래금액, 11, 10)) 최소거래금액
, to_number(substr(거래금액, 21)) 최대거래금액
-- ....
```

추가로, TYPE 을 사용하는 방법도 있으나 미리 TYPE 을 선언해두어야 해서 불편함 때문에 잘 쓰지 않는다.



#### (4-2) 스칼라 서브쿼리가 아닌, 인라인 뷰로 만들기

서브쿼리로 인라인 뷰를 구성하면 된다.

이는 위의 4.4.3 에서 봤던 내용!



### (5) 스칼라 서브쿼리 Unnesting

스칼라 서브쿼리도 NL 방식!
캐싱효과가 작다면? 랜덤 IO 부담이 있다!

따라서, 스칼라 서브쿼리를 일반 조인문으로 변환해서 다른 조인 방식을 택하고 싶을 수도 있다!
특히나, 대량 데이터를 처리하는 병렬 쿼리는 해시 조인으로 처리해야 효과적!

> 병렬 쿼리?
>
> - 단일 SQL 문을 서로 다른 프로세스/쓰레드에 의해 동시에 수행될 수 있는 일련의 작업으로 분할하여 이들을 동시에 실행시킬 수 있는 능력
> - Parallel Coordinator가 SQL문내의 각 연산자 분해

```sql
select c.고객번호, 
  (select /*+ unnest */ round(avg(거래금액), 2) 평균거래 금액
  	from 거래
   	-- where ...
  )
from 고객 c
-- where ...
```

unnest 할 경우 NL 조인이 아닌 해시 조인으로도 해결 가능!



