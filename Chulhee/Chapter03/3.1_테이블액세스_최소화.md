# 3. 인덱스 튜닝



# 3.1 테이블 액세스 최소화

2장까지는 인덱스 사용법에 익혀보았다면, 이제부터 SQL 튜닝을 공부해보자!

랜덤 I/O를 줄이는 것이 가장 중요한데, 
조인 메소드 발전은 물론 많은 튜닝 기법이 랜덤 I/O를 줄이기 위함이다!



## 3.1.1 테이블 랜덤 액세스

#### 인덱스에 대한 맹신 또는 섣부른 자신감

인덱스를 쓰면 무조건 빠른가? 그렇지는 않다!
대량 데이터를 조회하게 되면 더 느리다!

#### 인덱스 ROWID 는 물리적 주소? 논리적 주소?

sql이 참조하는 컬럼을 인덱스가 모두 포함하지 않는다면 반드시 테이블에 액세스한다!
실행 계획의 **TABLE ACCESS BY INDEX ROWID** 을 통해 알 수 있다.

예제와 함께!

```sql
SELECT * FROM 고객 WHERE 지역 = '서울'
```

이 쿼리의 실행 계획은

```
SELECT STATEMENT Optimizer=ALL_ROWS
TABLE ACCESS BY INDEX ROWID OF '고객' (TABLE)
INDEX RANGE SCAN OF '고객_지역_IDX' (INDEX)
```

- 인덱스 ROWID 는 논리적 주소!
  - 데이터파일 번호, 오브젝트 번호, 블록 번호와 같은 물리적 요소로 구성되어 있으나,
  - **테이블 레코드를 찾아가기 위한 논리적인 주소 정보를 담고있기 때문에 논리적 주소**
    - **디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보**
  - 그러므로 포인터와 같이 실제 주소를 가리키는 것이 아니다!



#### 메인 메모리 DB(MMDB)와 비교

**메인 메모리DB : 데이터를 모두 메모리에 로드해놓고 메모리 통해서만 I/O 수행하는 DB**

잘 튜닝된 OLTP DB 시스템이라면 버퍼 캐시 히트율이 99% 이상! (디스크를 경유하지 않고, 메모리에서 바로 읽는다)
그런데, **메인메모리 DB만큼 빠르지 않으며, 인덱스로 대량 데이터 접근할 경우 엄청난 차이!**

**왜 차이가 날까??**

메인 메모리 DB 아키텍처를 보면 알 수 있다!

메인 메모리 DB 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼 캐시로 로딩하고, 이어서 인덱스를 생성

이 때 인덱스는 오라클처럼 디스크 상의 주소 정보를 갖는 게 아니라,
메모리 상의 주소 정보, 즉 포인터를 갖는다!

따라서, 인덱스를 경유해 테이블을 액세스하는 비용이 오라클과 비교할 수 없을 정도로 낮다.

오라클은 테이블 블록이 수시로 버퍼캐시에서 밀려났다가 다시 캐싱되며,
그 때마다 다른 공간에 캐싱되기 때문에 인덱스에서 포인터로 직접 연결할 수 없다! (**위에서 ROWID 는 논리적 주소** 라고 이야기 한 것의 연장선!)

메모리 주소 정보(포인터)가 아닌, 디스크 주소 정보를 이용하여 해시 알고리즘으로 버퍼 블록을 찾아간다!

**결론!**

일반 DBMS 에서 인덱스 ROWID 를 이용한 테이블 액세스가 생각처럼 빠르지 않다!

**그래서 MMDB 쓰라고?**

그건 아님! 일단 위의 결론처럼 ROWID 이용한 접근이 빠르지 않다는 점이고, 
**주메모리를 쓰기 때문에 접근은 빠르지만, 휘발성이기 때문에 DB 전원 꺼지면? 자료 모두 날라간다!**
**추가적으로, 데이터에 비해 RAM 용량 적으면, 가상 메모리 필요로 하겠지? -> 오히려 역효과...** 

> 뭐, 필요할 때가 있지 않을까? MySQL 에서도 옵션으로 제공하기도 한다고 함!



#### I/O 메커니즘 복습

1.3 절에서 설명한 내용 복습!

DBA(데이터 파일번호 + 블록 번호)는 디스크 상에서 블록을 찾기 위한 주소 정보!

매번 디스크에서 블록을 읽지 않고 버퍼 캐시를 활용하자!

블록을 읽을 때

- 디스크로 가기 전, 버퍼 캐시 먼저 탐색
  - DBA를 해시 함수에 입력하여 해시 체인 찾고, 버퍼 헤더를 찾는다!
  - 캐시에 적재할 때, 읽을 때 모두 같은 해시 체인에 연결되지만, 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱된다
    - 이 논리적 주소로 버퍼 블록을 찾아간다!

인덱스로 테이블 블록 액세스 할 때는,

- 리프 블록에서 읽은 ROWID 를 분해해서 DBA 정보를 얻고,

테이블 FULL SCAN 시에는, 익스텐트 맵을 통해 읽을 블록들의 DBA 정보를 얻는다.

**모든 데이터가 캐싱되어 있으면?**

그래도 DBA 해싱과 래치 획득 과정을 반복해야 한다!

동시 액세스가 심할 때는, 캐시 버퍼 체인 래치와 버퍼 lock 에 대한 경합까지 발생!

> 래치가 뭐야?
>
> 오라클에서 Latch 는 Lock 과 함께 잠금에 사용되는 장치!
> latch는 락보다는 가볍고 SGA(System Global Area) 내부의 공유 데이터에 대한 배타적인 잠금을 보장!
>
> 추가적인 참고 : https://tawool.tistory.com/237 (래치 vs 락)



#### 인덱스 ROWID 는 우편주소

계속 했던 얘기!

**디스크DB의 ROWID** 는 우편 주소(찾아다녀야 한다!) 
**메인메모리 DB의 포인터**는 전화번호(바로 접근 가능!)

실행 계획에서 하나의 레코드를 찾는데 있어 가장 빠르다는 **ROWID에 의한 테이블 엑세스**는 생각보다 고비용이였다!



## 3.1.2 인덱스 클러스터링 팩터

클러스터링 팩터(Clustering Factor)는 군집성 계수로 번역할 수 있다.

 CF가 좋은 컬럼에 생성한 인덱스? 검색 효율 좋다!

**데이터가 물리적으로 근접해있다면 흩어져있을 때보다 검색이 빠르다!**

> 인덱스는 Single Block I/O 이고, 똑같이 계속 블록 읽어야 하는거 아니야??

인덱스 ROWID로 테이블에 액세스할 때,
버퍼 피닝(buffer pinning) 발생!

- 버퍼 피닝(buffer pinning) : 오라클은 래치 획득, 해시 체인 스캔 과정을 거쳐 얻은 블록에 대한 포인터를 바로 해제하지 않고 일단 유지한다!

다음 인덱스 레코드를 읽었는데 같은 블록을 가리킨다면?
래치 획득, 해시 체인 스캔 과정을 생략하고 바로 같은 블록 읽으면 된다!

한 블록에 레코드 여러개 들어있으니까~~

일종의 캐시! 
블록 주소 포인터 가지고 있고, 같은 블록 주소 나오면? 바로 포인터로 가자~~생각하면 될듯!



## 3.1.3 인덱스 손익분기점

다시 한 번 강조! 인덱스 ROWID 이용한 테이블 액세스는 고비용 구조다!
**그래서 항상 인덱스 이용한 READ가 빠르지 않다! 대량의 데이터를 읽으면 table full scan 이 빨랐었다!**

> 원인 중 하나가 싱글 블록 I/O 였기 때문! 이라고 했었다

Table Full Scan 은 몇 건을 조회하든 성능은 거의 일정! (y = c 꼴 그래프)

인덱스는 몇 건을 추출하느냐에 따라 달라진다! ( y = nx 꼴 그래프)

그 원인으로 2가지로 꼽자면!

- **Table Full Scan 은 시퀀셜 액세스 / 멀티 블록 I/O**
- **인덱스 ROWID 접근은 랜덤 액세스 / 싱글 블록  I/O**

이 때 손익분기점은 5 ~ 20% 정도의 낮은 수준에서 결정된다!

이 때 CF 값이 나쁘면 손익분기점은 더욱 낮아지고, 반대로 값이 좋으면 손익분기점이 90%까지 올라갈 수도 있다!

**즉, 인덱스가 항상 좋을 수는 없다!**



#### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

***조인과 파티션을 학습하지 않았다면 어렵다! 나중에 꼭 다시 읽어볼 것!!***





## 3.1.4 인덱스 컬럼 추가

테이블 액세스를 최소화 하는 가장 일반적인 튜닝 방법? 
**인덱스에 컬럼 추가하는 것!**

예시)

EMP 테이블에 PK이외 <DEPNO + JOB>으로 emp_x01이라는 인덱스 하나만 있는 상태에서 다음 쿼리를 수행해보자!

```sql
SELECT /*+ index(emp emp_x01) */ *
FROM EMP
WHERE DEPTNO = 30
AND SAL >= 2000
```

인덱스가 DEPNO + JOB 이기 때문에, DEPNO 값만 보고 인덱스를 이용하다보니, 
이 쿼리의 결과 값은 1명(소량)인데, 테이블 자체는 여러 번 액세스 하면서 where 조건에 맞는지 확인해야 한다!

가장 쉬운 해결 방법? index를 DEPNO + SAL 로 바꾸면 끝!이지만....
실제 운영 환경에서 인덱스 구성을 변경하기 쉽지 않다!
또한 인덱스를 추가하자니, 인덱스 관리비용 증가 및 DML 부하에 따른 트랜잭션 성능 저하가 생길 수 있다!

그렇다면?
기존 인덱스에 SAL 컬럼을 추가해주면 해결할 수 있다!

<DEPNO + JOB> 에서 <DEPNO + JOB + SAL> 로 !

**주의! ** 인덱스 스캔량은 동일하지만, 테이블 랜덤 액세스 횟수만 줄여준다!
SAL 값을 확인하기 위해 테이블 액세스할 필요만 없앴기 때문! order 자체는 index 구조에선 동일!



## 3.1.5 인덱스만 읽고 처리

위에서 필터 조건에 의해 버려지는 레코드가 많을 때 인덱스에 컬럼을 추가해서 테이블 액세스 줄여서 성능 개선했다!
하지만, **테이블 랜덤 액세스가 아무리 많아도, 필터 조건에 의해 버려지는 레코드가 거의 없다면??** 

반드시 성능을 개선해야한다면, 
쿼리에 사용된 모든 컬럼을 인덱스에 추가해서 테이블 액세스를 발생하지 않게 할 수 있다.
'이 때 인덱스만 읽어서 처리하는 쿼리를 Covered 쿼리라고 부르며, 인덱스는 Covered 인덱스라고 한다.'

> 근데 정말 안좋은 방법인 것 같다... 무분별한 인덱스 같은 느낌!



## 3.1.6 인덱스 구조 테이블

인덱스를 이용한 테이블 액세스가 고비용 구조?
**그러면 랜덤액세스가 발생하지 않도록 테이블을 인덱스 구조로 생성하면 어떨까?**

오라클에선 IOT(Index Organized Table), MS-SQL Server 에선 클러스터형 인덱스 라고 부른다!

인덱스 구조 테이블은
테이블 찾기 위한 ROWID를 갖는 인덱스와 달리,
ROWID 자리에 테이블 데이터를 갖는다!

**테이블 블록에 있어야할 데이터를 인덱스 리프 블록에 모두 저장하고 있는 것!**

이는 인위적으로 CF(클러스터링 팩터)를 좋게 만드는 방법 중 하나!

같은 값을 가진 데이터가 정렬된 상태로 모여있기 때문에 무조건 시퀀셜하게 데이터를 액세스한다!

-> BETWEEN 이나 부등호 조건에 매우 유리!



**단점은 뭘까?**

잦은 수정이 되겠지!

인텍스 블록에 전체 데이터를 가지는 것(조회의 장점)과 
잦은 인텍스 데이터 재구성(변경의 단점)과의 균형을 고려!



## 3.1.7 클러스터 테이블

- 인덱스 클러스터
- 해시 클러스터



### 인덱스 클러스터 테이블

: 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조

한 블록 내에 모두 못 담으면 클러스터 체인으로 연결하여 새로운 블록에 할당!

#### 클러스터 테이블 구성하기

1. 클러스터 생성
2. 클러스터 인덱스 정의
3. 클러스터 테이블 생성

클러스터 인덱스는 일반 인덱스 구조와 구조는 동일.(B+Tree)
다만 테이블 레코드를 일일이 가리키지 않고, **해당 키 값을 저장하는 첫 번째 데이터 블록을 가리킨다.**

따라서, 클러스터 인덱스를 스캔하면서 값을 찾으면
**랜덤 액세스가 값 하나당 한번만 발생!**



### 해시 클러스터 테이블

해시 클러스터는 클러스터 인덱스 대신 **해시 알고리즘을 이용해서 클러스터를 찾아간다!**

#### 해시 클러스터 테이블 구성하기

1. 해시로 클러스터 생성
2. 클러스터 테이블 생성



















