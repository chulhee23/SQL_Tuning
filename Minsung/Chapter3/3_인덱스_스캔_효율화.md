# 3.3 인덱스 스캔 효율화

운영 환경에서 가장 일반적인 튜닝 기법은 인덱스 칼럼 추가입니다.

인덱스 스캔 효율화는 튜닝 요소가 매우 다양합니다.



## 3.3.2 인덱스 스캔 효율성

인덱스 스캔 효율성을 높이기 위해서는 인덱스 선행 컬럼이 조건절에 있어야 합니다.

인덱스 선행 칼럼이 조건절에 없거나 = 조건이 아니면 인덱스 스캔 과정에 비효율이 발생합니다.



### 인덱스 스캔 효율성 측정

인덱스 스캔 효율성을 측정하기 위해서는 SQL 트레이스를 통해 쉽게 알 수 있습니다.

```
Rows     Row Source Operation
10       TABLE ACCESS BY INDEX ROWID BIG_TABLE (cr=7471 pr=1466 pw=0 time=22137 us)
10           INDEX RANGE SCAN BIG_TABLE_IDX (cr=7463 pr=1466 pw=0 time=22328 us)
```



위 트레이스를 보면 인덱스를 스캔하고 10개의 Rows를 얻었습니다.

이를 위해 7463개의 블록을 읽었고, 인덱스 리프 블록에는 훨씬 더 많은 레코드가 담기니까 한 블록 당 평균 500개 레코드가 담긴다고 하면 3,731,500(=7,463*500)개 레코드를 읽은 것입니다.

즉 저 많은 데이터를 읽고 10개를 얻은거면 비효율적이라고 볼 수 있습니다.

​                                                                                                                                                                                       

## 3.3.3 액세스 조건과 필터 조건

인덱스 스캔 효율성을 계속 설명하기에 앞서 반드시 이해해야 할 용어가 두 가지 있습니다.

액세스 조건과 필터 조건입니다.

![image-20210809233922034](../images/Chapter3/액세스조건과_필터조건.png)

인덱스 액세스 조건은 인덱스 스캔 범위를 결정하는 조건절입니다.

인덱스를 수직적 탐색하여 스캔 시작점과 끝지점을 결정합니다.

인덱스 필터 조건은 테이블로 액세스할지를 결정하는 조건절입니다.





## 3.3.4 비교 연산자 종류와 칼럼 순서에 따른 군집성

선행 칼럼이 모두 =조건인 상태에서 첫 번째 나타나는 범위 검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서  모여있지만 그 이하 조건까지 만족하는 레코느는 비교 연산자 종류에 상관없이 흩어집니다.

아래 예시를 봅시다.

``` SQL
WHERE C1 = 1
AND C2 = 'A'
AND C3 BETWEEN '가' AND '다'
AND C4 = 'a'
```



첫 번째 나타나는 범위 검색 조건인 C3까지는 인덱스 레코드가 모두 모여있지만 C4까지 만족하는 레코드는 그 안에서 흩어지게 됩니다.

이 경우 인덱스 액세스 조건은 C1, C2, C3가 되고 인덱스 필터 조건은 C4가 됩니다.



## 3.3.5 인덱스 선행 칼럼이 등치(=) 조건이 아닐 때 생기는 비효율

인덱스 스캔 효율성은 인덱스 칼럼을 조건절에 모두 = 조건으로 사용할 때가 가장 좋습니다.

이 경우 리프노드를 스캔하면서 읽은 레코드가 전부 테이블 액세스로 이어지므로 비효율이 발생하지 않습니다.



인덱스 칼럼 중 일부가 조건절에 없거나 = 조건이 아니더라도 그것이 인덱스의 뒤쪽 컬럼일수록 비효율이 감소합니다.

인덱스가 (아파트시세코드, 평형, 평형타입, 인터넷매물)로 이루어져 있을 때 아래 쿼리를 생각해봅시다.

``` SQL
SELECT 해당층
FROM 매물아파트매매
WHERE 아파트시세코 = 'A010'
AND 평형 = '59'
AND 평형타입 = 'A'
AND 인터넷매물 between '1' and '3'
```



인덱스의 가장 마지막 칼럼인 (인터넷매물)이 = 조건이 아닌 between이지만 비효율이 발생하지 않습니다.

3.3.4에서 봤듯이 첫 번째 범위 검색 조건까지는 데이터들이 군집을 이루고 있습니다.



만약 인덱스를 바꿔 인터넷매물 칼럼이 앞 쪽에 위치한다면 그 뒤 쪽 데이터는 흩어져 있게 되므로 비효율이 발생합니다.



## 3.3.6 BETWEEN을 IN-List로 전환

위처럼 범위검색 칼럼이 맨 뒤로 가도록 인덱스를 변경하면 좋겠지만 인덱스의 구성을 바꾸기 쉽지 않습니다.

이 때는 BETWEEN 조건을 아래와 같이 IN-List로 바꿔주면 큰 효과를 얻을 수 있습니다.

이 경우, BETWEEN 조건에 들어가는 모든 값들을 = 조건으로 각각 검색한 후 union all을 하게 됩니다.

즉 각각에 대하여 효율적인 인덱스 탐색이 이루어지게 되는 것이죠.

하지만 IN-List 내에 항목 개수가 늘어날 수 있다면 해당 방식은 오히려 더 비효율적으로 바뀔 가능성이 있습니다.



### BETWEEN 조건을 IN-List로 전환할 때 주의 사항

BETWEEN 조건을 IN-List 조건으로 전환할 때 주의할 점은 IN-List의 개수입니다.

개수가 많다면 수직적 탐색이 많이 발생하고 리프노드를 많이 스캔하는 것보다 비효율적일 수 있습니다.

또한 인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져있을 때만 유용합니다.

가까이 있다면 리프노드를 얼마 탐색안하고도 멈출 수 있습니다.



## 3.3.7 Index Skip Scan 활용

BETWEEN 조건을 IN-List 조건으로 변환하면 도움이 되는 상황에서 Index Skip Scan을 사용해도 효과가 있습니다.



월별고객판매집계 테이블에 2018년 1월부터 12월까지 월별로 10만 개의 판매데이터가 있습니다.

총 120만개이고, 이 중 판매구분값으로는 A가 10만 개, B가 110만 개입니다.



아래와 같은 쿼리를 수행한다고 가정합시다.

``` SQL
SELECT COUNT(*)
FROM 월별고객별판매집계 T
WHERE 판매구분 = 'A'
AND 판매월 BETWEEN '201801' AND '201812'
```



해당 쿼리를 최적으로 수행하려면 = 조건은 판매구분이 선두칼럼에 위치하도록 (판매구분, 판매월)과 같이 인덱스를 구성해야합니다.

인덱스가 (판매월, 판매구분) 일 경우에는 Index Skip Scan을 사용하여 성능을 개선할 수 있습니다.

선두 칼럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때 Index Skip Scan이 좋습니다.



## 3.3.8 IN 조건은 =인가

흔히들 IN 조건을 = 조건과 동등시 합니다.

두 개의 인덱스 (상품ID, 고객번호), (고객번호, 상품ID)에 대해 아래 쿼리는 어떤 차이가 있을까요?

``` SQL
SELECT *
FROM 고객별가입상품
WHERE 고객번호 = :cust_no
AND 상품ID in ('NH00037', 'NH00041', 'NH00050')
```



고객별가입상품 테이블에서 고객번호의 평균 카디널리티는 3이라고 합시다.

즉, 고객별로 평균 세 건의 상품을 가입합니다.

이 상황에서 인덱스를 (상품ID, 고객번호) 으로 생성하면 같은 상품은 고객번호 순으로 정렬된 상태로 하나의 리프노드에 저장됩니다.

반면, 고객번호 기준으로는 같은 고객번호가 상품ID에 따라 흩어진 상태가 됩니다.

고객번호가 흩어져있는 이런 상황에서는 상품ID 조건절이 IN-List Iterator 방식으로 풀리는 것이 효과적입니다.

아래와 같이 말이죠.

```SQL
SELECT *
FROM 고객별가입상품
WHERE 고객번호 = :cust_no
AND 상품ID = 'NH00037'
UNION ALL
SELECT *
FROM 고객별가입상품
WHERE 고객번호 = :cust_no
AND 상품ID = 'NH00041'
UNION ALL
SELECT *
FROM 고객별가입상품
WHERE 고객번호 = :cust_no
AND 상품ID = 'NH00050'
```

고객번호와 상품ID 둘 다 인덱스액세스 조건으로 사용됩니다.



이번에는 (상품ID, 고객번호) 인덱스를 생각해봅시다.

이제 같은 고객은 상품ID 순으로 정렬된 상태로 같은 리프노드에 저장됩니다.

![image-20210811173925052](../images/Chapter3/IN-List_Iterator.png)



이제 다시 IN-List Iterator 방식으로 푼다고 생각을 해봅시다.

각 상품번호에 대한 SELECT 쿼리가 3개 생성되고 각각 수직적으로 내려오면서 3개의 블록을 탐색, 즉 9개의 블록을 읽게 됩니다.



IN-List Iterator 방식으로 풀지 않지 않으면 상품ID 조건절은 필터로 처리합니다.

그러면 고객번호만 액세스 조건이므로 고객번호 1234인 레코드를 모두 스캔하고 모두 한 블록에 모여있으므로 총 3개의 블록만을 탐색합니다.



즉, IN 조건은 =이 아닙니다. 

IN-List Iterator 방식으로 풀려야 = 조건이 되고 그렇지 않으면 필터조건일 뿐입니다.

앞에서 봤듯이 IN-List Iterator 푸는 것이 항상 효과적이진 않습니다.

위 상황에서 IN-List Iterator로 풀려서 상품ID가 액세스 조건으로 의미가 있으려면 고객별 상품 데이터가 아주 많아야합니다.





### NUM_INDEX_KEYS 힌트 활용

 `NUM_INDEX_KEYS` 을 사용하면 인덱스 액세스 조건을 어디 칼럼까지 사용할 지 지정할 수 있습니다.

힌트의 세 번째 인자가 1이면 인덱스 첫 번째 칼럼까지만 액세스 조건으로 사용하라는 의미입니다.

```SQL
SELECT /*+ NUM_INDEX_KEYS(a 고객별가입상품_X1 1)*/ *
FROM 고객별가입상품 a
WHERE 고객번호 = :cust_no
AND 상품ID in ('NH00037', 'NH00041', 'NH00050')
```



아니면 인덱스 칼럼을 가공하는 방법도 있습니다.

```SQL
SELECT *
FROM 고객별가입상품 a
WHERE 고객번호 = :cust_no
AND 상품ID || '' in ('NH00037', 'NH00041', 'NH00050')
```



## 3.3.9 BETWEEN과 LIKE 스캔 범위 비교

BETWEEN과 LIKE는 둘 다 범위검색 조건으로서 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 서로 다릅니다.

사용하기에는 LIKE가 더 편하지만 BETWEEN을 사용하면 적어도 손해는 안봅니다.



인덱스를 (판매월, 판매구분)으로 설정하고 판매구분은 A와 B가 90%, 10% 존재합니다.

이 상황에서 인덱스 스캔량을 확인해봅시다.

``` SQL
-- 조건절 1
WHERE 판매월 BETWEEN '201901' AND '201912'
AND 판매구분 = 'B'

-- 조건절 2
WHERE 판매월 LIKE '2019%'
AND 판매구분 = 'B'
```



조건절 1은 판매월 201901 이고 판매구분이 B인 레코드에서 스캔을 시작합니다.

반면 조건절 2는 판매월 201901인 첫 번째 레코드에서 스캔을 시작합니다.

혹시라도 201900이 저장되어 있을 수 있기 때문에 판매구분이 B인 지점으로 바로 내려갈 수 없습니다.



## 3.3.10 범위검색 조건을 남용할 때 생기는 비효율

사용자 입력과 선택에 따라 조건절이 다양하게 바뀔 때 SQL을 간편하게 작성하려고 조건절을 모두 LIKE로 구사하기도 하는데 해당 칼럼이 인덱스에 포함되어 있을 경우에는 주의가 필요합니다.



회사코드, 지역코드, 상품명 등을 입력함으로써 가입상품 테이블에서 데이터를 조회하는 프로그램이 있다고 가정합시다.

인덱스는 (회사코드, 지역코드, 상품명)인 상황입니다.

조회 화면에서 회사코드는 반드시 입력하지만 지역코드는 입력하지 않을 수 도 있습니다.

그리고 상품명은 단어 중 일부만 입력할 수 있습니다.

따라서 이 프로그램은 내부에서 아래 두 쿼리 중 하나를 선택적으로 사용할 것 입니다.

``` SQL
-- 회사코드, 지역코드, 상품명을 모두 입력할 때
SELECT *
FROM 가입상품
WHERE 회사코드 = :com
AND 지역코드 =:reg
AND 상품명 LIKE :prod || '%'

-- 회사코드, 상품명을 입력할 때
SELECT *
FROM 가입상품
WHERE 회사코드 = :com
AND 상품명 LIKE :prod || '%'
```



인덱스 중간 칼럼인 지역코드를 검색 할 때는 세 컬럼 모두 액세스 조건으로 아주 적은 범위만 스캔하고 빠르게 결과를 낼 수 있습니다.

하지만 지역코드 칼럼이 없는 경우에는 인덱스가 회사코드에만 걸려서 넓은 범위를 스캔하게 됩니다.

하지만 아래와 같이 지역코드를 LIKE로 바꾼다고 가정합시다.

```SQL
SELECT *
FROM 가입상품
WHERE 회사코드 = :com
AND 지역코드 LIKE :reg || '%'
AND 상품명 LIKE :prod || '%'
```



회사코드와 상품명만을 입력할 때는 인덱스 스캔 범위가 그대로지만,

회사코드, 지역코드, 상품명을 모두 입력할 때는 스캔 범위가 증가합니다.

원래는 액세스 조건이던 상품명이 필터 조건으로 바뀌면서 생긴 변화입니다.



## 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교

### OR 조건 활용

``` SQL
SELECT *
FROM 거래
WHERE (:cust_id is null or 고객ID = :cust_id)
AND 거래일자 BETWEEN :dt1 AND :dt2
```



해당 쿼리는 (고객ID, 거래일자)를 인덱스로 지정해도 사용할 수 없습니다.

인덱스 선두 칼럼에 대한 옵션 조건에 OR 조건을 사용해서는 안됩니다.

OR 조건을 활용한 결과는 아래와 같습니다.

* 인덱스 액세스 조건으로 사용 불가
* 인덱스 필터 조건으로도 사용 불가
* 테이블 필터 조건으로만 사용 가능 
* 단 인덱스 구성 칼럼 중 하나 이상이 Not Null 칼럼이면 18c부터 인덱스 필터 조건으로 사용 가능



### LIKE/BETWEEN 조건 활용

LIKE/BETWEEN 패턴을 사용하고자 할 때는 아래 네 가지 경우에 속하는지 반드시 점검해야합니다.

1. 인덱스 선두 칼럼
2. NULL 허용 칼럼
3. 숫자형 칼럼
4. 가변 길이 칼럼



네 가지에 대해서 하나씩 알아봅시다.

#### 인덱스 선두 칼럼

인덱스 선두 칼럼에 대한 조건을 LIKE/BETWEEN으로 하는 것은 좋지 않습니다.

아래 쿼리를 봅시다.

``` SQL
SELECT *
FROM 거래
WHERE 고객ID LIKE :cust_id || '%'
AND 거래일자 BETWEEN :dt1 AND :dt2
```



인덱스를 (고객ID, 거래일자)사용자가 고객 ID를 입력하면 둘 다 범위검색 조건이라 인덱스 스캔 과정에서 비효율이 있더라도 고객ID가 변별력이 매우 좋기 때문에 비교적 빠르게 조회됩니다.

만약에 사용자가 고객ID를 입력하지 않으면 인덱스에서 모든 거래 데이터를 스캔하면서 거래일자 조건을 필터링하는 문제가 생깁니다.

이 경우에는 (거래일자, 고객ID)로 인덱스를 구성해야 합니다.

이 때 고객ID가 입력되어도 특정 고객ID가 아닌 거래일자에 해당되는 모든 데이터를 스캔하겠지만 감수해야합니다.



#### NULL 허용 칼럼

성능을 떠나 결과 집합에 오류가 생기게 됩니다.

위 SQL에 must_id가 NULL이라면 아래와 같은 형태가 됩니다.

```SQL
SELECT *
FROM 거래
WHERE 고객ID LIKE '%'
AND 거래일자 BETWEEN :dt1 AND :dt2
```



만약 고객ID 칼럼이 NULL 허용이고 NULL 값이 입력돼 있다면 그 데이터는 결과에서 누락됩니다.



#### 숫자형 칼럼

숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 칼럼에 대해서는 LIKE 방식을 사용해서는 안됩니다.

고객ID가 만약 숫자형 칼럼이라면 아래와 같이 자동 형변환이 일어나므로 고객ID가 필터 조건으로 사용되는 문제가 생깁니다.

``` SQL
SELECT *
FROM 거래
WHERE 거래일자 = dt1
AND TO_CHAR(고객ID) LIKE :cust_id || '%'
```



#### 가변 길이 칼럼

LIKE를 옵션 조건에 사용할 때는 칼럼 값 길이가 고정적이어야 합니다.

강민이라는 고객을 찾기 위해 강민으로 검색했을 때 강민성이라는 고객도 함께 검색됩니다.

``` SQL
WHERE 고객명 LIKE :cust_nm || '%'
```



이 경우에는 입력되는 데이터 길이도 조건절에 함께 추가해야 합니다.



### UNION ALL 활용

아래와 같이 UNION ALL을 이용하는 방법도 있습니다.

:cust_id 변수에 값이 위 아래 중 하나만 실행되게 하는 방식입니다.

``` SQL
SELECT *
FROM 거래
WHERE :cust_id IS NULL
AND 거래일자 BETWEEN :dt1 and :dt2
UNION ALL
SELECT *
FROM 거래
WHERE :cust_id IS NOT NULL
AND 고객ID = :cust_id
AND 거래일자 BETWEEN :dt1 and :dt2
```



이 패턴을 사용하면 :cust_id 변수에 값을 입력하든 안 하든 인덱스를 가장 최적으로 사용합니다.

위 쪽은 거래일자를, 아래 쪽은 고객ID와 거래일자를 모두 액세스 조건으로 사용하기 때문입니다.



### NVL/DECODE 함수 활용

```SQL
SELECT *
FROM 거래
WHERE 고객ID = NVL(:cust_id, 고객ID)
AND 거래일자 BETWEEN :dt1 AND :dt2
```

``` SQL
SELECT *
FROM 거래
WHERE 고객ID = DECODE(:cust_id, NULL, 고객ID, :cust_id)
AND 거래일자 BETWEEN :dt1 AND :dt2
```



## 3.3.12 함수호출부하 해소를 위한 인덱스 구성

### PL/SQL 함수의 성능적 특성

PL/SQL 사용자 정의 함수는 개발자들이 생각하는 것 보다 매우 느립니다.

느린 이유는 아래와 같습니다.

* 가상머신 상에서 실행되는 인터프리터 언어

  PL/SQL로 작성한 함수와 프로시저를 컴파일하면 JAVA언어처럼 바이트코드를 생성해서 데이터 딕셔너리에 저장합니다.

  그러기 때문에 Native 코드로 완전 컴파일된 내장함수에 비해 많이 느립니다.

* 호출 시마다 컨텍스트 스위칭 발생

  SQL 실행엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭이 일어납니다.

* 내장 SQL에 대한 Recursive Call 발생

  아래 SQL에서 조건을 만족하는 회원이 100만 명이면  GET_ADDR도 100만 번 실행하는데 만약 함수에 SQL이 내장돼 있으면 그 SQL도 100만 번 실행됩니다.

  ```sql
  SELECT GET_ADDR(우편번호)
  FROM 회원
  WHERE 생월일 LIKE '01%'
  ```



### 효과적인 인덱스 구성을 통한 함수호출 최소화

테이블을 Full Scan으로 읽으면 아래 encryption 함수는 테이블 건수만큼 수행됩니다.

```SQL
SELECT /*+ full(a) */ 회원번호
FROM 회원 a
WHERE 암호화된_전화번호 = encryption( :phone_no )
```



하지만 아래와 같이 다른 조건절이 있으면 해당 조건절을 만족하는 건수만큼 수행됩니다.

``` SQL
SELECT /*+ full(a) */ 회원번호
FROM 회원 a
WHERE 생년 = '1987'
AND 암호화된_전화번호 = encryption( :phone_no )
```



3개의 인덱스에 대해서 얼마만큼 수행되는지 확인해봅시다.

#### (생년) 인덱스

암호화된_전화번호 조건절을 테이블 액세스 단계에서 필터링합니다.

따라서 생년 1987 조건을 만족하는 건수만큼 수행됩니다.

#### (생년, 생월일, 암호화된_전화번호) 인덱스

생월일에 대한 조건이 없으므로 암호화된_전화번호는 인덱스 필터 조건입니다.

따라서 생년 1987 조건을 만족하는 건수만큼 수행됩니다.

#### (생년, 암호화된_전화번호) 인덱스

이 경우 암호화된_전화번호도 인덱스 액세스 조건으로 사용됩니다.

따라서 함수는 단 한 번 수행됩니다.

